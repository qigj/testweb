

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Push Down Aggregation Operations &mdash; SynxDB Elastic Documentation Preview documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=53dc447f" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=f1f14d95"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=529101c1"></script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Execute Queries in Parallel" href="execute-queries-in-parallel.html" />
    <link rel="prev" title="Automatically Use Materialized Views for Query Optimization" href="use-auto-mtv-for-query-optimization.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            SynxDB Elastic Documentation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../product-overview/product-index.html">Product Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../deploy-guides/deploy-guides-index.html">Deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../load-data/load-data-index.html">Load Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../operate-with-data/operate-with-data-index.html">Operate with Data</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../optimize-performance-index.html">Optimize Performance</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="optimize-queries-index.html">Optimize Query Performance</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="optimize-query-performance-overview.html">Query Performance Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="use-orca/use-orca-index.html">Use GPORCA Optimizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="update-statistics.html">Update Statistics</a></li>
<li class="toctree-l3"><a class="reference internal" href="query-hints.html">Query Hints</a></li>
<li class="toctree-l3"><a class="reference internal" href="use-auto-mtv-for-query-optimization.html">Automatically Use Materialized Views for Query Optimization</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Push Down Aggregation Operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#usage-example">Usage example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#applicable-scenarios">Applicable scenarios</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scenarios-where-it-is-not-recommended">Scenarios where it is not recommended</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usage-limitations">Usage limitations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="execute-queries-in-parallel.html">Execute Queries in Parallel</a></li>
<li class="toctree-l3"><a class="reference internal" href="auto-clustering.html">Auto-Clustering Tables</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manage-system/manage-system-index.html">Manage System</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security-and-permissions/set-security-and-permission-index.html">Configure Security and Permissions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develop-guides/develop-with-db-index.html">Developer Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/tutorials-index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references/references-index.html">Reference Guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SynxDB Elastic Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../optimize-performance-index.html">Optimize Performance</a></li>
          <li class="breadcrumb-item"><a href="optimize-queries-index.html">Optimize Query Performance</a></li>
      <li class="breadcrumb-item active">Push Down Aggregation Operations</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="push-down-aggregation-operations">
<h1>Push Down Aggregation Operations<a class="headerlink" href="#push-down-aggregation-operations" title="Link to this heading"></a></h1>
<p>Aggregation pushdown is an optimization technique that moves aggregation operations closer to the data source. SynxDB Elastic supports pushing down aggregations by performing the aggregation operator before the join operator.</p>
<p>In appropriate scenarios, aggregation pushdown can significantly reduce the size of the input set for the join or aggregation operator, thereby improving the operator’s execution performance.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>In the native PostgreSQL optimizer logic, aggregation operations in a query are always performed after all join operations have been completed (excluding subqueries). Therefore, SynxDB Elastic introduces the aggregation pushdown feature, allowing it to choose to perform aggregation operations earlier in suitable scenarios.</p></li>
<li><p>To determine whether the execution plan chosen by the optimizer has applied the aggregation pushdown optimization, you can observe the positional relationship between Aggregation and Join in the execution plan tree. If an execution plan first performs a Partial Aggregation, then a Join, and finally a Final Aggregation, it means the optimizer has applied aggregation pushdown.</p></li>
</ul>
</div>
<section id="usage-example">
<h2>Usage example<a class="headerlink" href="#usage-example" title="Link to this heading"></a></h2>
<p>Before using this optimization, you need to manually enable the GUC parameter <code class="docutils literal notranslate"><span class="pre">gp_enable_agg_pushdown</span></code>.</p>
<p>Additionally, you need to manually set <code class="docutils literal notranslate"><span class="pre">optimizer=off</span></code> to disable the GPORCA optimizer, as this optimization currently only works in the PostgreSQL optimizer.</p>
<p>Here is an example of using aggregation pushdown optimization.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Creates two tables, t1 and t2.</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">t1</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="nb">INT</span><span class="p">,</span><span class="w"> </span><span class="n">val1</span><span class="w"> </span><span class="nb">INT</span><span class="p">);</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">t2</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="nb">INT</span><span class="p">,</span><span class="w"> </span><span class="n">val2</span><span class="w"> </span><span class="nb">INT</span><span class="p">);</span>

<span class="k">SET</span><span class="w"> </span><span class="n">OPTIMIZER</span><span class="o">=</span><span class="k">OFF</span><span class="p">;</span><span class="w"> </span><span class="c1">-- Disable the GPORCA optimizer</span>
<span class="k">SET</span><span class="w"> </span><span class="n">gp_enable_agg_pushdown</span><span class="o">=</span><span class="k">ON</span><span class="p">;</span><span class="w"> </span><span class="c1">-- Enable the GUC parameter</span>

<span class="c1">-- Executes a query with aggregation and join operations.</span>
<span class="k">EXPLAIN</span><span class="w"> </span><span class="p">(</span><span class="n">COSTS</span><span class="w"> </span><span class="k">OFF</span><span class="p">)</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">SUM</span><span class="p">(</span><span class="n">val1</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">NATURAL</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">                     </span><span class="n">QUERY</span><span class="w"> </span><span class="n">PLAN</span>
<span class="c1">-----------------------------------------------------</span>
<span class="w"> </span><span class="n">Gather</span><span class="w"> </span><span class="n">Motion</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span><span class="mi">1</span><span class="w">  </span><span class="p">(</span><span class="n">slice1</span><span class="p">;</span><span class="w"> </span><span class="n">segments</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="w">   </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Finalize</span><span class="w"> </span><span class="n">GroupAggregate</span>
<span class="w">         </span><span class="k">Group</span><span class="w"> </span><span class="k">Key</span><span class="p">:</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">id</span>
<span class="w">         </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Sort</span>
<span class="w">               </span><span class="n">Sort</span><span class="w"> </span><span class="k">Key</span><span class="p">:</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">id</span>
<span class="w">               </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Hash</span><span class="w"> </span><span class="k">Join</span>
<span class="w">                     </span><span class="n">Hash</span><span class="w"> </span><span class="n">Cond</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
<span class="w">                     </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Seq</span><span class="w"> </span><span class="n">Scan</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">t2</span>
<span class="w">                     </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Hash</span>
<span class="w">                           </span><span class="o">-&gt;</span><span class="w">  </span><span class="k">Partial</span><span class="w"> </span><span class="n">HashAggregate</span>
<span class="w">                                 </span><span class="k">Group</span><span class="w"> </span><span class="k">Key</span><span class="p">:</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">id</span>
<span class="w">                                 </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Seq</span><span class="w"> </span><span class="n">Scan</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">t1</span>
<span class="n">Optimizer</span><span class="p">:</span><span class="w"> </span><span class="n">Postgres</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="n">optimizer</span>
<span class="p">(</span><span class="mi">13</span><span class="w"> </span><span class="k">rows</span><span class="p">)</span>
</pre></div>
</div>
<p>From the execution plan result in the example above, you can see that before performing the HashJoin operation, SynxDB Elastic first performs an aggregation on the <code class="docutils literal notranslate"><span class="pre">t1</span></code> table based on the <code class="docutils literal notranslate"><span class="pre">id</span></code> column. This aggregation does not compromise the correctness of the statement result and is likely to reduce the amount of data entering the HashJoin, thus improving the statement’s execution efficiency.</p>
</section>
<section id="applicable-scenarios">
<h2>Applicable scenarios<a class="headerlink" href="#applicable-scenarios" title="Link to this heading"></a></h2>
<p>Using aggregation pushdown in the following scenarios is expected to yield significant query performance improvements.</p>
<section id="scenario-1">
<h3>Scenario 1<a class="headerlink" href="#scenario-1" title="Link to this heading"></a></h3>
<p><strong>Scenario description</strong>: Each record in one table corresponds to multiple records in another table, and the two tables need to be joined for a grouped aggregation.</p>
<p>For example, you need to join an <code class="docutils literal notranslate"><span class="pre">order_tbl</span></code> with an <code class="docutils literal notranslate"><span class="pre">order_line_tbl</span></code> and calculate the total amount for each order by summing the prices of its corresponding order items, i.e., <code class="docutils literal notranslate"><span class="pre">SUM(price)</span></code>:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">order_id</span><span class="p">,</span><span class="w"> </span><span class="k">SUM</span><span class="p">(</span><span class="n">price</span><span class="p">)</span>
<span class="w">  </span><span class="k">FROM</span><span class="w"> </span><span class="n">order_tbl</span><span class="w"> </span><span class="n">o</span><span class="p">,</span><span class="w"> </span><span class="n">order_line_tbl</span><span class="w"> </span><span class="n">ol</span>
<span class="w">  </span><span class="k">WHERE</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">order_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ol</span><span class="p">.</span><span class="n">order_id</span>
<span class="w">  </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">order_id</span><span class="p">;</span>
</pre></div>
</div>
<ul>
<li><p><strong>Execution in the native PostgreSQL optimizer</strong>: The native PostgreSQL optimizer can only join the two tables first and then perform the aggregation. Because every order item in <code class="docutils literal notranslate"><span class="pre">order_line_tbl</span></code> must have a corresponding order in <code class="docutils literal notranslate"><span class="pre">order_tbl</span></code>, the Join operator will not filter out any data.</p></li>
<li><p><strong>With aggregation pushdown</strong>: Assuming each order contains an average of 10 order items, the data volume is expected to decrease by a factor of 10 after the Aggregation operator. With aggregation pushdown enabled, the database will first aggregate the data in <code class="docutils literal notranslate"><span class="pre">order_line_tbl</span></code> by <code class="docutils literal notranslate"><span class="pre">order_id</span></code>. This reduces the amount of data passed to the Join operator by a factor of 10, significantly lowering the cost of the Join. The corresponding execution plan is as follows:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">order_id</span><span class="p">,</span><span class="w"> </span><span class="k">SUM</span><span class="p">(</span><span class="n">price</span><span class="p">)</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">order_tbl</span><span class="w"> </span><span class="n">o</span><span class="p">,</span><span class="w"> </span><span class="n">order_line_tbl</span><span class="w"> </span><span class="n">ol</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">order_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ol</span><span class="p">.</span><span class="n">order_id</span>
<span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">order_id</span><span class="p">;</span>
<span class="w">                                        </span><span class="n">QUERY</span><span class="w"> </span><span class="n">PLAN</span>
<span class="c1">-----------------------------------------------------------------------------------------------</span>
<span class="n">Gather</span><span class="w"> </span><span class="n">Motion</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span><span class="mi">1</span><span class="w">  </span><span class="p">(</span><span class="n">slice1</span><span class="p">;</span><span class="w"> </span><span class="n">segments</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">712</span><span class="p">.</span><span class="mi">89</span><span class="p">..</span><span class="mi">879</span><span class="p">.</span><span class="mi">56</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">10000</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="o">-&gt;</span><span class="w">  </span><span class="n">Finalize</span><span class="w"> </span><span class="n">HashAggregate</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">712</span><span class="p">.</span><span class="mi">89</span><span class="p">..</span><span class="mi">746</span><span class="p">.</span><span class="mi">23</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">3333</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="w">        </span><span class="k">Group</span><span class="w"> </span><span class="k">Key</span><span class="p">:</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">order_id</span>
<span class="w">        </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Hash</span><span class="w"> </span><span class="k">Join</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">617</span><span class="p">.</span><span class="mi">00</span><span class="p">..</span><span class="mi">696</span><span class="p">.</span><span class="mi">23</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">3333</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="w">            </span><span class="n">Hash</span><span class="w"> </span><span class="n">Cond</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="n">ol</span><span class="p">.</span><span class="n">order_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">order_id</span><span class="p">)</span>
<span class="w">            </span><span class="o">-&gt;</span><span class="w">  </span><span class="k">Partial</span><span class="w"> </span><span class="n">HashAggregate</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">538</span><span class="p">.</span><span class="mi">00</span><span class="p">..</span><span class="mi">571</span><span class="p">.</span><span class="mi">38</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">3338</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="w">                    </span><span class="k">Group</span><span class="w"> </span><span class="k">Key</span><span class="p">:</span><span class="w"> </span><span class="n">ol</span><span class="p">.</span><span class="n">order_id</span>
<span class="w">                    </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Seq</span><span class="w"> </span><span class="n">Scan</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">order_line_tbl</span><span class="w"> </span><span class="n">ol</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="p">..</span><span class="mi">371</span><span class="p">.</span><span class="mi">33</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">33333</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="w">            </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Hash</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">37</span><span class="p">.</span><span class="mi">33</span><span class="p">..</span><span class="mi">37</span><span class="p">.</span><span class="mi">33</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">3333</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="w">                    </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Seq</span><span class="w"> </span><span class="n">Scan</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">order_tbl</span><span class="w"> </span><span class="n">o</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="p">..</span><span class="mi">37</span><span class="p">.</span><span class="mi">33</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">3333</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Optimizer</span><span class="p">:</span><span class="w"> </span><span class="n">Postgres</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="n">optimizer</span>
</pre></div>
</div>
</li>
</ul>
<p>A similar scenario is joining a <code class="docutils literal notranslate"><span class="pre">project</span></code> table with an <code class="docutils literal notranslate"><span class="pre">experiment</span></code> table to calculate the total experiment cost for each project over the past year. The reference SQL statement is as follows:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">proj_name</span><span class="p">,</span><span class="w"> </span><span class="k">sum</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
<span class="w">    </span><span class="k">FROM</span><span class="w"> </span><span class="n">experiment</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">project</span><span class="w"> </span><span class="n">p</span>
<span class="w">    </span><span class="k">WHERE</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">e_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">p_pid</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">start_time</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">now</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">interval</span><span class="w"> </span><span class="s1">&#39;1 year&#39;</span>
<span class="w">    </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">proj_name</span><span class="p">;</span>
</pre></div>
</div>
<p>For this query, with aggregation pushdown enabled, SynxDB Elastic will pre-aggregate the <code class="docutils literal notranslate"><span class="pre">experiment</span></code> table by the <code class="docutils literal notranslate"><span class="pre">e_pid</span></code> column, grouping information for the same project first.</p>
<p>However, if this query also involves significant filtering on the <code class="docutils literal notranslate"><span class="pre">project</span></code> table, the join selectivity might become too high, leading to inefficient execution. Therefore, aggregation pushdown is not currently suitable for this situation.</p>
</section>
<section id="scenario-2">
<h3>Scenario 2<a class="headerlink" href="#scenario-2" title="Link to this heading"></a></h3>
<p><strong>Scenario description</strong>: The Join operator in the query significantly expands the result set, which ultimately needs to be grouped for calculation.</p>
<p>For example, joining a <code class="docutils literal notranslate"><span class="pre">person_1</span></code> table with a <code class="docutils literal notranslate"><span class="pre">person_2</span></code> table to find out how many different pairs can be formed for each common name between the two tables:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">person_1</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">person_2</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</pre></div>
</div>
<p>In this example, if a <code class="docutils literal notranslate"><span class="pre">name</span></code> appears X times in the <code class="docutils literal notranslate"><span class="pre">p1</span></code> table and Y times in the <code class="docutils literal notranslate"><span class="pre">p2</span></code> table, that <code class="docutils literal notranslate"><span class="pre">name</span></code> will appear X*Y times in the final result. If a large amount of data fits this pattern, the result set after the join could be very large.</p>
<p>In the example above, if the aggregation is pushed down to either the <code class="docutils literal notranslate"><span class="pre">p1</span></code> or <code class="docutils literal notranslate"><span class="pre">p2</span></code> side, each <code class="docutils literal notranslate"><span class="pre">name</span></code> will appear at most once after aggregation on that side. This effectively reduces the cost of the Join operator and the size of the input set for the subsequent Aggregation operator. The corresponding execution plan is as follows:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">person_1</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">person_2</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="w">                                       </span><span class="n">QUERY</span><span class="w"> </span><span class="n">PLAN</span>
<span class="c1">-----------------------------------------------------------------------------------------</span>
<span class="w"> </span><span class="n">Gather</span><span class="w"> </span><span class="n">Motion</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span><span class="mi">1</span><span class="w">  </span><span class="p">(</span><span class="n">slice1</span><span class="p">;</span><span class="w"> </span><span class="n">segments</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">1758</span><span class="p">.</span><span class="mi">62</span><span class="p">..</span><span class="mi">1925</span><span class="p">.</span><span class="mi">23</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">9997</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="w">   </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Finalize</span><span class="w"> </span><span class="n">HashAggregate</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">1758</span><span class="p">.</span><span class="mi">62</span><span class="p">..</span><span class="mi">1791</span><span class="p">.</span><span class="mi">94</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">3332</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="w">         </span><span class="k">Group</span><span class="w"> </span><span class="k">Key</span><span class="p">:</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">name</span>
<span class="w">         </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Hash</span><span class="w"> </span><span class="k">Join</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">762</span><span class="p">.</span><span class="mi">93</span><span class="p">..</span><span class="mi">1592</span><span class="p">.</span><span class="mi">17</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">33290</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="w">               </span><span class="n">Hash</span><span class="w"> </span><span class="n">Cond</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="n">p2</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
<span class="w">               </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Seq</span><span class="w"> </span><span class="n">Scan</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">p2</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="p">..</span><span class="mi">371</span><span class="p">.</span><span class="mi">33</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">33333</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="w">               </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Hash</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">637</span><span class="p">.</span><span class="mi">97</span><span class="p">..</span><span class="mi">637</span><span class="p">.</span><span class="mi">97</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">9997</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="w">                     </span><span class="o">-&gt;</span><span class="w">  </span><span class="k">Partial</span><span class="w"> </span><span class="n">HashAggregate</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">538</span><span class="p">.</span><span class="mi">00</span><span class="p">..</span><span class="mi">637</span><span class="p">.</span><span class="mi">97</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">9997</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="w">                           </span><span class="k">Group</span><span class="w"> </span><span class="k">Key</span><span class="p">:</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">name</span>
<span class="w">                           </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Seq</span><span class="w"> </span><span class="n">Scan</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">p1</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="p">..</span><span class="mi">371</span><span class="p">.</span><span class="mi">33</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">33333</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="w"> </span><span class="n">Optimizer</span><span class="p">:</span><span class="w"> </span><span class="n">Postgres</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="n">optimizer</span>
<span class="p">(</span><span class="mi">11</span><span class="w"> </span><span class="k">rows</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="scenarios-where-it-is-not-recommended">
<h2>Scenarios where it is not recommended<a class="headerlink" href="#scenarios-where-it-is-not-recommended" title="Link to this heading"></a></h2>
<p>Aggregation pushdown is unlikely to provide performance benefits in the following scenarios and is not recommended.</p>
<section id="not-recommended-scenario-1">
<h3>Not recommended scenario 1<a class="headerlink" href="#not-recommended-scenario-1" title="Link to this heading"></a></h3>
<p><strong>Scenario description</strong>: Scenarios where aggregation does not significantly change the data volume.</p>
<p>Contrary to the applicable scenarios above, if performing the aggregation early does not change the data volume and cannot reduce the input set size for subsequent calculations, the Join operator should be executed first to avoid unnecessary overhead.</p>
</section>
<section id="not-recommended-scenario-2">
<h3>Not recommended scenario 2<a class="headerlink" href="#not-recommended-scenario-2" title="Link to this heading"></a></h3>
<p><strong>Scenario description</strong>: If the join key is different from the grouping key, aggregation pushdown will cause the grouping key to change after being pushed down. In this case, the aggregation after rewriting the grouping key cannot reduce the data volume, leading to poor pushdown effectiveness:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="k">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="k">key</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
</pre></div>
</div>
<p>For the query example above, directly pushing down the aggregation to the <code class="docutils literal notranslate"><span class="pre">t1</span></code> side would lead to incorrect results, similar to the situation in Limitation 1. To ensure the correctness of the calculation, the actual grouping key for the pushed-down aggregation would be equivalent to <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span> <span class="pre">t1.key,</span> <span class="pre">t1.value</span></code>.</p>
<p>In this case, if the <code class="docutils literal notranslate"><span class="pre">key</span></code> and <code class="docutils literal notranslate"><span class="pre">value</span></code> in the <code class="docutils literal notranslate"><span class="pre">t1</span></code> table are completely unrelated, each group might contain only a single tuple, so this aggregation pushdown will not have any positive effect. However, if <code class="docutils literal notranslate"><span class="pre">key</span></code> and <code class="docutils literal notranslate"><span class="pre">value</span></code> are strongly correlated, or if the same <code class="docutils literal notranslate"><span class="pre">key</span></code> always corresponds to the same <code class="docutils literal notranslate"><span class="pre">value</span></code>, the grouping effectiveness will not be affected.</p>
<p>In the example above, grouping by <code class="docutils literal notranslate"><span class="pre">t1.value</span></code> was originally effective. But after aggregation pushdown, the grouping key becomes <code class="docutils literal notranslate"><span class="pre">t1.key,</span> <span class="pre">t1.value</span></code>. If <code class="docutils literal notranslate"><span class="pre">key</span></code> and <code class="docutils literal notranslate"><span class="pre">value</span></code> have a weak correlation, this aggregation will not produce a significant effect.</p>
</section>
</section>
<section id="usage-limitations">
<h2>Usage limitations<a class="headerlink" href="#usage-limitations" title="Link to this heading"></a></h2>
<p>This section describes some limitations of the aggregation pushdown feature, including cases where this optimization is logically inapplicable and cases that are not yet supported by the engineering implementation.</p>
<section id="limitation-1">
<h3>Limitation 1<a class="headerlink" href="#limitation-1" title="Link to this heading"></a></h3>
<p><strong>Limitation description</strong>: Aggregation pushdown cannot be applied when filtering is performed on columns other than the <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> columns during the join and subsequent calculations. Consider the following SQL query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">SUM</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">val</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">val</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
</pre></div>
</div>
<p>In the example above, assume there are two tuples A and B from the <code class="docutils literal notranslate"><span class="pre">t1</span></code> table with <code class="docutils literal notranslate"><span class="pre">id</span></code> = <code class="docutils literal notranslate"><span class="pre">100</span></code>, and a tuple C from the <code class="docutils literal notranslate"><span class="pre">t2</span></code> table also with <code class="docutils literal notranslate"><span class="pre">id</span></code> = <code class="docutils literal notranslate"><span class="pre">100</span></code>.</p>
<p>During the join of AB and C, even though A and B have the same <code class="docutils literal notranslate"><span class="pre">id</span></code>, it is not guaranteed that they will both pass or fail the <code class="docutils literal notranslate"><span class="pre">AB.val</span> <span class="pre">&gt;</span> <span class="pre">C.val</span></code> filter condition simultaneously. In this situation, pre-aggregating the <code class="docutils literal notranslate"><span class="pre">val</span></code> based on <code class="docutils literal notranslate"><span class="pre">id</span></code> would inevitably sum the <code class="docutils literal notranslate"><span class="pre">val</span></code> of A and B together. However, since they do not necessarily pass or fail the filter condition at the same time, this would lead to incorrect results.</p>
<p>In contrast, the following similar query example can apply aggregation pushdown:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">SUM</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">id_thre</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
</pre></div>
</div>
<p>This example also considers the same three tuples A, B, and C as in the previous example. Because the additional filter condition only uses the <code class="docutils literal notranslate"><span class="pre">id</span></code> column from <code class="docutils literal notranslate"><span class="pre">t1</span></code>, when the two tuples A and B with the same <code class="docutils literal notranslate"><span class="pre">id</span></code> are joined with tuple C, they will either both pass the filter or both fail. Therefore, the <code class="docutils literal notranslate"><span class="pre">val</span></code> of tuples A and B can be summed up in advance through an aggregation operation.</p>
</section>
<section id="limitation-2">
<h3>Limitation 2<a class="headerlink" href="#limitation-2" title="Link to this heading"></a></h3>
<p><strong>Limitation description</strong>: Pushing down aggregations to both sides of a Join at the same time is not supported. Consider the following SQL query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">SUM</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
</pre></div>
</div>
<p>We can actually rewrite the statement to get an equivalent one:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">sum1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cnt2</span><span class="w"> </span><span class="k">FROM</span>
<span class="w">    </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">SUM</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="n">AT1</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">sum1</span><span class="p">),</span>
<span class="w">    </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="n">AT2</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">cnt2</span><span class="p">)</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">AT1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AT2</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
</pre></div>
</div>
<p>In this example, the aggregation operation is pushed down to both sides of the Join. For all tuples in <code class="docutils literal notranslate"><span class="pre">t1</span></code> with <code class="docutils literal notranslate"><span class="pre">id</span></code> = <code class="docutils literal notranslate"><span class="pre">100</span></code>, SynxDB Elastic pre-aggregates their <code class="docutils literal notranslate"><span class="pre">val</span></code> to get the corresponding <code class="docutils literal notranslate"><span class="pre">sum1</span></code>.</p>
<p>During the actual join process, for each tuple in <code class="docutils literal notranslate"><span class="pre">t2</span></code> with <code class="docutils literal notranslate"><span class="pre">id</span></code> = <code class="docutils literal notranslate"><span class="pre">100</span></code>, it will be joined with the tuple containing <code class="docutils literal notranslate"><span class="pre">sum1</span></code> to produce a corresponding result tuple. This means that for every <code class="docutils literal notranslate"><span class="pre">id</span></code> = <code class="docutils literal notranslate"><span class="pre">100</span></code> in <code class="docutils literal notranslate"><span class="pre">t2</span></code>, <code class="docutils literal notranslate"><span class="pre">sum1</span></code> will appear once in the final summation. Therefore, SynxDB Elastic can pre-aggregate <code class="docutils literal notranslate"><span class="pre">t2</span></code> to calculate that there are a total of <code class="docutils literal notranslate"><span class="pre">cnt2</span></code> tuples with <code class="docutils literal notranslate"><span class="pre">id</span></code> = <code class="docutils literal notranslate"><span class="pre">100</span></code>, and finally calculate the result using <code class="docutils literal notranslate"><span class="pre">sum1</span> <span class="pre">*</span> <span class="pre">cnt2</span></code>.</p>
<p>Because this scenario involves relatively complex statement and expression rewriting, it is not currently supported in the product.</p>
</section>
</section>
</section>


           </div>
          </div>
          


  <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      <a href="execute-queries-in-parallel.html" class="btn btn-neutral float-right" title="Execute Queries in Parallel" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      <a href="use-auto-mtv-for-query-optimization.html" class="btn btn-neutral float-left" title="Automatically Use Materialized Views for Query Optimization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
  </div>

<footer class="footer">
  <div class="container">
    <div class="footer-content">
      <div class="footer-section">
        <p>&copy; 2025, Synx Data Labs, Inc. All rights reserved.</p>
      </div>
      <div class="footer-section">
        <p>SynxDB Elastic Documentation</p>
      </div>
    </div>
  </div>
</footer>

<style>
.footer {
  background-color: var(--bg-secondary);
  border-top: 1px solid var(--border);
  padding: 1.5rem 0;
  margin-top: 3rem;
}

.footer-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 2rem;
}

.footer-section p {
  margin: 0;
  color: var(--text-secondary);
  font-size: 0.9rem;
  font-family: 'Inter', sans-serif;
}

@media (max-width: 768px) {
  .footer-content {
    flex-direction: column;
    gap: 0.5rem;
    text-align: center;
  }
}
</style>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>