<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Reading and Writing Text Data - SynxDB 2 Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SynxDB 2 Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                        &nbsp;&nbsp;&nbsp;&nbsp;
                        <a href="https://www.synxdata.com/"><img id="fa fa-print" src="../SYNX-Text-and-Circular-Logo-142x28-White-text-Black-background.png" alt="Synx Data Labs Logo"/></a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="reading-and-writing-hdfs-text-data"><a class="header" href="#reading-and-writing-hdfs-text-data">Reading and Writing HDFS Text Data</a></h1>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->
<p>The PXF HDFS Connector supports plain delimited and comma-separated value form text data. This section describes how to use PXF to access HDFS text data, including how to create, query, and insert data into an external table that references files in the HDFS data store.</p>
<p>PXF supports reading or writing text files compressed with the <code>default</code>, <code>bzip2</code>, and <code>gzip</code> codecs.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites"><a id="prereq"></a>Prerequisites</a></h2>
<p>Ensure that you have met the PXF Hadoop <a href="access_hdfs.html#hadoop_prereq">Prerequisites</a> before you attempt to read data from or write data to HDFS.</p>
<h2 id="reading-text-data"><a class="header" href="#reading-text-data"><a id="profile_text"></a>Reading Text Data</a></h2>
<p>Use the <code>hdfs:text</code> profile when you read plain text delimited, and <code>hdfs:csv</code> when reading .csv data where each row is a single record. The following syntax creates a SynxDB readable external table that references such a text file on HDFS: </p>
<pre><code class="language-sql">CREATE EXTERNAL TABLE &lt;table_name&gt; 
    ( &lt;column_name&gt; &lt;data_type&gt; [, ...] | LIKE &lt;other_table&gt; )
LOCATION ('pxf://&lt;path-to-hdfs-file&gt;?PROFILE=hdfs:text|csv[&amp;SERVER=&lt;server_name&gt;][&amp;IGNORE_MISSING_PATH=&lt;boolean&gt;][&amp;SKIP_HEADER_COUNT=&lt;numlines&gt;]')
FORMAT '[TEXT|CSV]' (delimiter[=|&lt;space&gt;][E]'&lt;delim_value&gt;');
</code></pre>
<p>The specific keywords and values used in the SynxDB <a href="../ref_guide/sql_commands/CREATE_EXTERNAL_TABLE.html">CREATE EXTERNAL TABLE</a> command are described in the table below.</p>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th>Value</th></tr></thead><tbody>
<tr><td>&lt;path‑to‑hdfs‑file&gt;</td><td>The path to the directory or file in the HDFS data store. When the <code>&lt;server_name&gt;</code> configuration includes a <a href="cfg_server.html#pxf-fs-basepath"><code>pxf.fs.basePath</code></a> property setting, PXF considers &lt;path‑to‑hdfs‑file&gt; to be relative to the base path specified. Otherwise, PXF considers it to be an absolute path. &lt;path‑to‑hdfs‑file&gt; must not specify a relative path nor include the dollar sign (<code>$</code>) character.</td></tr>
<tr><td>PROFILE</td><td>Use <code>PROFILE</code> <code>hdfs:text</code> when &lt;path-to-hdfs-file&gt; references plain text delimited data.<br> Use <code>PROFILE</code> <code>hdfs:csv</code> when &lt;path-to-hdfs-file&gt; references comma-separated value data.</td></tr>
<tr><td>SERVER=&lt;server_name&gt;</td><td>The named server configuration that PXF uses to access the data. PXF uses the <code>default</code> server if not specified.</td></tr>
<tr><td>IGNORE_MISSING_PATH=&lt;boolean&gt;</td><td>Specify the action to take when &lt;path-to-hdfs-file&gt; is missing or invalid. The default value is <code>false</code>, PXF returns an error in this situation. When the value is <code>true</code>, PXF ignores missing path errors and returns an empty fragment.</td></tr>
<tr><td>SKIP_HEADER_COUNT=&lt;numlines&gt;</td><td>Specify the number of header lines that PXF should skip in the first split of each &lt;hdfs-file&gt; before reading the data. The default value is 0, do not skip any lines.</td></tr>
<tr><td>FORMAT</td><td>Use <code>FORMAT</code> <code>'TEXT'</code> when &lt;path-to-hdfs-file&gt; references plain text delimited data.<br> Use <code>FORMAT</code> <code>'CSV'</code>  when &lt;path-to-hdfs-file&gt; references comma-separated value data.</td></tr>
<tr><td>delimiter</td><td>The delimiter character in the data. For <code>FORMAT</code> <code>'CSV'</code>, the default &lt;delim_value&gt; is a comma (<code>,</code>). Preface the &lt;delim_value&gt; with an <code>E</code> when the value is an escape sequence. Examples: <code>(delimiter=E'\t')</code>, <code>(delimiter ':')</code>.</td></tr>
</tbody></table>
</div>
<p><strong>Note</strong>: PXF does not support the <code>(HEADER)</code> formatter option in the <code>CREATE EXTERNAL TABLE</code> command. If your text file includes header line(s), use <code>SKIP_HEADER_COUNT</code> to specify the number of lines that PXF should skip at the beginning of the first split of each file.</p>
<h3 id="example-reading-text-data-on-hdfs"><a class="header" href="#example-reading-text-data-on-hdfs"><a id="profile_text_query"></a>Example: Reading Text Data on HDFS</a></h3>
<p>Perform the following procedure to create a sample text file, copy the file to HDFS, and use the <code>hdfs:text</code> and <code>hdfs:csv</code> profiles and the default PXF server to create two PXF external tables to query the data:</p>
<ol>
<li>
<p>Create an HDFS directory for PXF example data files. For example:</p>
<pre><code class="language-shell">$ hdfs dfs -mkdir -p /data/pxf_examples
</code></pre>
</li>
<li>
<p>Create a delimited plain text data file named <code>pxf_hdfs_simple.txt</code>:</p>
<pre><code class="language-shell">$ echo 'Prague,Jan,101,4875.33
Rome,Mar,87,1557.39
Bangalore,May,317,8936.99
Beijing,Jul,411,11600.67' &gt; /tmp/pxf_hdfs_simple.txt
</code></pre>
<p>Note the use of the comma (<code>,</code>) to separate the four data fields.</p>
</li>
<li>
<p>Add the data file to HDFS:</p>
<pre><code class="language-shell">$ hdfs dfs -put /tmp/pxf_hdfs_simple.txt /data/pxf_examples/
</code></pre>
</li>
<li>
<p>Display the contents of the <code>pxf_hdfs_simple.txt</code> file stored in HDFS:</p>
<pre><code class="language-shell">$ hdfs dfs -cat /data/pxf_examples/pxf_hdfs_simple.txt
</code></pre>
</li>
<li>
<p>Start the <code>psql</code> subsystem:</p>
<pre><code class="language-shell">$ psql -d postgres
</code></pre>
</li>
<li>
<p>Use the PXF <code>hdfs:text</code> profile to create a SynxDB external table that references the <code>pxf_hdfs_simple.txt</code> file that you just created and added to HDFS:</p>
<pre><code class="language-sql">postgres=# CREATE EXTERNAL TABLE pxf_hdfs_textsimple(location text, month text, num_orders int, total_sales float8)
            LOCATION ('pxf://data/pxf_examples/pxf_hdfs_simple.txt?PROFILE=hdfs:text')
          FORMAT 'TEXT' (delimiter=E',');
</code></pre>
</li>
<li>
<p>Query the external table:</p>
<pre><code class="language-sql">postgres=# SELECT * FROM pxf_hdfs_textsimple;          
</code></pre>
<pre><code class="language-pre">   location    | month | num_orders | total_sales 
---------------+-------+------------+-------------
 Prague        | Jan   |        101 |     4875.33
 Rome          | Mar   |         87 |     1557.39
 Bangalore     | May   |        317 |     8936.99
 Beijing       | Jul   |        411 |    11600.67
(4 rows)
</code></pre>
</li>
<li>
<p>Create a second external table that references <code>pxf_hdfs_simple.txt</code>, this time specifying the <code>hdfs:csv</code> <code>PROFILE</code> and the <code>CSV</code> <code>FORMAT</code>:</p>
<pre><code class="language-sql">postgres=# CREATE EXTERNAL TABLE pxf_hdfs_textsimple_csv(location text, month text, num_orders int, total_sales float8)
            LOCATION ('pxf://data/pxf_examples/pxf_hdfs_simple.txt?PROFILE=hdfs:csv')
          FORMAT 'CSV';
postgres=# SELECT * FROM pxf_hdfs_textsimple_csv;          
</code></pre>
<p>When you specify <code>FORMAT 'CSV'</code> for comma-separated value data, no <code>delimiter</code> formatter option is required because comma is the default delimiter value.</p>
</li>
</ol>
<h2 id="reading-text-data-with-quoted-linefeeds"><a class="header" href="#reading-text-data-with-quoted-linefeeds"><a id="profile_textmulti"></a>Reading Text Data with Quoted Linefeeds</a></h2>
<p>Use the <code>hdfs:text:multi</code> profile to read plain text data with delimited single- or multi- line records that include embedded (quoted) linefeed characters. The following syntax creates a SynxDB readable external table that references such a text file on HDFS:</p>
<pre><code class="language-sql">CREATE EXTERNAL TABLE &lt;table_name&gt;
    ( &lt;column_name&gt; &lt;data_type&gt; [, ...] | LIKE &lt;other_table&gt; )
LOCATION ('pxf://&lt;path-to-hdfs-file&gt;?PROFILE=hdfs:text:multi[&amp;SERVER=&lt;server_name&gt;][&amp;IGNORE_MISSING_PATH=&lt;boolean&gt;][&amp;SKIP_HEADER_COUNT=&lt;numlines&gt;]')
FORMAT '[TEXT|CSV]' (delimiter[=|&lt;space&gt;][E]'&lt;delim_value&gt;');
</code></pre>
<p>The specific keywords and values used in the <a href="../ref_guide/sql_commands/CREATE_EXTERNAL_TABLE.html">CREATE EXTERNAL TABLE</a> command are described in the table below.</p>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th>Value</th></tr></thead><tbody>
<tr><td>&lt;path‑to‑hdfs‑file&gt;</td><td>The path to the directory or file in the HDFS data store. When the <code>&lt;server_name&gt;</code> configuration includes a <a href="cfg_server.html#pxf-fs-basepath"><code>pxf.fs.basePath</code></a> property setting, PXF considers &lt;path‑to‑hdfs‑file&gt; to be relative to the base path specified. Otherwise, PXF considers it to be an absolute path. &lt;path‑to‑hdfs‑file&gt; must not specify a relative path nor include the dollar sign (<code>$</code>) character.</td></tr>
<tr><td>PROFILE</td><td>The <code>PROFILE</code> keyword must specify <code>hdfs:text:multi</code>.</td></tr>
<tr><td>SERVER=&lt;server_name&gt;</td><td>The named server configuration that PXF uses to access the data. PXF uses the <code>default</code> server if not specified.</td></tr>
<tr><td>IGNORE_MISSING_PATH=&lt;boolean&gt;</td><td>Specify the action to take when &lt;path-to-hdfs-file&gt; is missing or invalid. The default value is <code>false</code>, PXF returns an error in this situation. When the value is <code>true</code>, PXF ignores missing path errors and returns an empty fragment.</td></tr>
<tr><td>SKIP_HEADER_COUNT=&lt;numlines&gt;</td><td>Specify the number of header lines that PXF should skip in the first split of each &lt;hdfs-file&gt; before reading the data. The default value is 0, do not skip any lines.</td></tr>
<tr><td>FORMAT</td><td>Use <code>FORMAT</code> <code>'TEXT'</code> when &lt;path-to-hdfs-file&gt; references plain text delimited data.<br> Use <code>FORMAT</code> <code>'CSV'</code> when &lt;path-to-hdfs-file&gt; references comma-separated value data.</td></tr>
<tr><td>delimiter</td><td>The delimiter character in the data. For <code>FORMAT</code> <code>'CSV'</code>, the default &lt;delim_value&gt; is a comma (<code>,</code>). Preface the &lt;delim_value&gt; with an <code>E</code> when the value is an escape sequence. Examples: <code>(delimiter=E'\t')</code>, <code>(delimiter ':')</code>.</td></tr>
</tbody></table>
</div>
<p><strong>Note</strong>: PXF does not support the <code>(HEADER)</code> formatter option in the <code>CREATE EXTERNAL TABLE</code> command. If your text file includes header line(s), use <code>SKIP_HEADER_COUNT</code> to specify the number of lines that PXF should skip at the beginning of the first split of each file.</p>
<h3 id="example-reading-multi-line-text-data-on-hdfs"><a class="header" href="#example-reading-multi-line-text-data-on-hdfs"><a id="profile_textmulti_query"></a>Example: Reading Multi-Line Text Data on HDFS</a></h3>
<p>Perform the following steps to create a sample text file, copy the file to HDFS, and use the PXF <code>hdfs:text:multi</code> profile and the default PXF server to create a SynxDB readable external table to query the data:</p>
<ol>
<li>
<p>Create a second delimited plain text file:</p>
<pre><code class="language-shell">$ vi /tmp/pxf_hdfs_multi.txt
</code></pre>
</li>
<li>
<p>Copy/paste the following data into <code>pxf_hdfs_multi.txt</code>:</p>
<pre><code class="language-pre">"4627 Star Rd.
San Francisco, CA  94107":Sept:2017
"113 Moon St.
San Diego, CA  92093":Jan:2018
"51 Belt Ct.
Denver, CO  90123":Dec:2016
"93114 Radial Rd.
Chicago, IL  60605":Jul:2017
"7301 Brookview Ave.
Columbus, OH  43213":Dec:2018
</code></pre>
<p>Notice the use of the colon <code>:</code> to separate the three fields. Also notice the quotes around the first (address) field. This field includes an embedded line feed separating the street address from the city and state.</p>
</li>
<li>
<p>Copy the text file to HDFS:</p>
<pre><code class="language-shell">$ hdfs dfs -put /tmp/pxf_hdfs_multi.txt /data/pxf_examples/
</code></pre>
</li>
<li>
<p>Use the <code>hdfs:text:multi</code> profile to create an external table that references the <code>pxf_hdfs_multi.txt</code> HDFS file, making sure to identify the <code>:</code> (colon) as the field separator:</p>
<pre><code class="language-sql">postgres=# CREATE EXTERNAL TABLE pxf_hdfs_textmulti(address text, month text, year int)
            LOCATION ('pxf://data/pxf_examples/pxf_hdfs_multi.txt?PROFILE=hdfs:text:multi')
          FORMAT 'CSV' (delimiter ':');
</code></pre>
<p>Notice the alternate syntax for specifying the <code>delimiter</code>.</p>
</li>
<li>
<p>Query the <code>pxf_hdfs_textmulti</code> table:</p>
<pre><code class="language-sql">postgres=# SELECT * FROM pxf_hdfs_textmulti;
</code></pre>
<pre><code class="language-pre">         address          | month | year 
--------------------------+-------+------
 4627 Star Rd.            | Sept  | 2017
 San Francisco, CA  94107           
 113 Moon St.             | Jan   | 2018
 San Diego, CA  92093               
 51 Belt Ct.              | Dec   | 2016
 Denver, CO  90123                  
 93114 Radial Rd.         | Jul   | 2017
 Chicago, IL  60605                 
 7301 Brookview Ave.      | Dec   | 2018
 Columbus, OH  43213                
(5 rows)
</code></pre>
</li>
</ol>
<h2 id="writing-text-data-to-hdfs"><a class="header" href="#writing-text-data-to-hdfs"><a id="hdfswrite_text"></a>Writing Text Data to HDFS</a></h2>
<p>The PXF HDFS connector profiles <code>hdfs:text</code> and <code>hdfs:csv</code> support writing single line plain text data to HDFS. When you create a writable external table with the PXF HDFS connector, you specify the name of a directory on HDFS. When you insert records into a writable external table, the block(s) of data that you insert are written to one or more files in the directory that you specified.</p>
<p><strong>Note</strong>: External tables that you create with a writable profile can only be used for <code>INSERT</code> operations. If you want to query the data that you inserted, you must create a separate readable external table that references the HDFS directory.</p>
<p>Use the following syntax to create a SynxDB writable external table that references an HDFS directory: </p>
<pre><code class="language-sql">CREATE WRITABLE EXTERNAL TABLE &lt;table_name&gt; 
    ( &lt;column_name&gt; &lt;data_type&gt; [, ...] | LIKE &lt;other_table&gt; )
LOCATION ('pxf://&lt;path-to-hdfs-dir&gt;
    ?PROFILE=hdfs:text|csv[&amp;SERVER=&lt;server_name&gt;][&amp;&lt;custom-option&gt;=&lt;value&gt;[...]]')
FORMAT '[TEXT|CSV]' (delimiter[=|&lt;space&gt;][E]'&lt;delim_value&gt;');
[DISTRIBUTED BY (&lt;column_name&gt; [, ... ] ) | DISTRIBUTED RANDOMLY];
</code></pre>
<p>The specific keywords and values used in the <a href="../ref_guide/sql_commands/CREATE_EXTERNAL_TABLE.html">CREATE EXTERNAL TABLE</a> command are described in the table below.</p>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th>Value</th></tr></thead><tbody>
<tr><td>&lt;path‑to‑hdfs‑dir&gt;</td><td>The path to the directory in the HDFS data store. When the <code>&lt;server_name&gt;</code> configuration includes a <a href="cfg_server.html#pxf-fs-basepath"><code>pxf.fs.basePath</code></a> property setting, PXF considers &lt;path‑to‑hdfs‑dir&gt; to be relative to the base path specified. Otherwise, PXF considers it to be an absolute path. &lt;path‑to‑hdfs‑dir&gt; must not specify a relative path nor include the dollar sign (<code>$</code>) character.</td></tr>
<tr><td>PROFILE</td><td>Use <code>PROFILE</code> <code>hdfs:text</code> to write plain, delimited text to &lt;path-to-hdfs-file&gt;.<br> Use <code>PROFILE</code> <code>hdfs:csv</code> to write comma-separated value text to &lt;path-to-hdfs-dir&gt;.</td></tr>
<tr><td>SERVER=&lt;server_name&gt;</td><td>The named server configuration that PXF uses to access the data. PXF uses the <code>default</code> server if not specified.</td></tr>
<tr><td>&lt;custom‑option&gt;</td><td>&lt;custom-option&gt;s are described below.</td></tr>
<tr><td>FORMAT</td><td>Use <code>FORMAT</code> <code>'TEXT'</code> to write plain, delimited text to &lt;path-to-hdfs-dir&gt;.<br> Use <code>FORMAT</code> <code>'CSV'</code> to write comma-separated value text to &lt;path-to-hdfs-dir&gt;.</td></tr>
<tr><td>delimiter</td><td>The delimiter character in the data. For <code>FORMAT</code> <code>'CSV'</code>, the default &lt;delim_value&gt; is a comma (<code>,</code>). Preface the &lt;delim_value&gt; with an <code>E</code> when the value is an escape sequence. Examples: <code>(delimiter=E'\t')</code>, <code>(delimiter ':')</code>.</td></tr>
<tr><td>DISTRIBUTED BY</td><td>If you want to load data from an existing SynxDB table into the writable external table, consider specifying the same distribution policy or <code>&lt;column_name&gt;</code> on both tables. Doing so will avoid extra motion of data between segments on the load operation.</td></tr>
</tbody></table>
</div>
<p>Writable external tables that you create using the <code>hdfs:text</code> or the <code>hdfs:csv</code> profiles can optionally use record or block compression. You specify the compression codec via a custom option in the <code>CREATE EXTERNAL TABLE</code> <code>LOCATION</code> clause. The <code>hdfs:text</code> and <code>hdfs:csv</code> profiles support the following custom write option:</p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Value Description</th></tr></thead><tbody>
<tr><td>COMPRESSION_CODEC</td><td>The compression codec alias. Supported compression codecs for writing text data include: <code>default</code>, <code>bzip2</code>, <code>gzip</code>, and <code>uncompressed</code>. If this option is not provided, SynxDB performs no data compression.</td></tr>
</tbody></table>
</div>
<h3 id="example-writing-text-data-to-hdfs"><a class="header" href="#example-writing-text-data-to-hdfs"><a id="write_hdfstextsimple_example"></a>Example: Writing Text Data to HDFS</a></h3>
<p>This example utilizes the data schema introduced in <a href="#profile_text_query">Example: Reading Text Data on HDFS</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>Column Name</th><th>Data Type</th></tr></thead><tbody>
<tr><td>location</td><td>text</td></tr>
<tr><td>month</td><td>text</td></tr>
<tr><td>number_of_orders</td><td>int</td></tr>
<tr><td>total_sales</td><td>float8</td></tr>
</tbody></table>
</div>
<p>This example also optionally uses the SynxDB external table named <code>pxf_hdfs_textsimple</code> that you created in that exercise.</p>
<h4 id="procedure"><a class="header" href="#procedure"><a id="write_hdfstextsimple_proc" class="no-quick-link"></a>Procedure</a></h4>
<p>Perform the following procedure to create SynxDB writable external tables utilizing the same data schema as described above, one of which will employ compression. You will use the PXF <code>hdfs:text</code> profile and the default PXF server to write data to the underlying HDFS directory. You will also create a separate, readable external table to read the data that you wrote to the HDFS directory.</p>
<ol>
<li>
<p>Create a SynxDB writable external table utilizing the data schema described above. Write to the HDFS directory <code>/data/pxf_examples/pxfwritable_hdfs_textsimple1</code>. Create the table specifying a comma (<code>,</code>) as the delimiter:</p>
<pre><code class="language-sql">postgres=# CREATE WRITABLE EXTERNAL TABLE pxf_hdfs_writabletbl_1(location text, month text, num_orders int, total_sales float8)
            LOCATION ('pxf://data/pxf_examples/pxfwritable_hdfs_textsimple1?PROFILE=hdfs:text')
          FORMAT 'TEXT' (delimiter=',');
</code></pre>
<p>You specify the <code>FORMAT</code> subclause <code>delimiter</code> value as the single ascii comma character <code>,</code>.</p>
</li>
<li>
<p>Write a few individual records to the <code>pxfwritable_hdfs_textsimple1</code> HDFS directory by invoking the SQL <code>INSERT</code> command on <code>pxf_hdfs_writabletbl_1</code>:</p>
<pre><code class="language-sql">postgres=# INSERT INTO pxf_hdfs_writabletbl_1 VALUES ( 'Frankfurt', 'Mar', 777, 3956.98 );
postgres=# INSERT INTO pxf_hdfs_writabletbl_1 VALUES ( 'Cleveland', 'Oct', 3812, 96645.37 );
</code></pre>
</li>
<li>
<p>(Optional) Insert the data from the <code>pxf_hdfs_textsimple</code> table that you created in [Example: Reading Text Data on HDFS] (#profile_text_query) into <code>pxf_hdfs_writabletbl_1</code>:</p>
<pre><code class="language-sql">postgres=# INSERT INTO pxf_hdfs_writabletbl_1 SELECT * FROM pxf_hdfs_textsimple;
</code></pre>
</li>
<li>
<p>In another terminal window, display the data that you just added to HDFS:</p>
<pre><code class="language-shell">$ hdfs dfs -cat /data/pxf_examples/pxfwritable_hdfs_textsimple1/*
Frankfurt,Mar,777,3956.98
Cleveland,Oct,3812,96645.37
Prague,Jan,101,4875.33
Rome,Mar,87,1557.39
Bangalore,May,317,8936.99
Beijing,Jul,411,11600.67
</code></pre>
<p>Because you specified comma (<code>,</code>) as the delimiter when you created the writable external table, this character is the field separator used in each record of the HDFS data.</p>
</li>
<li>
<p>SynxDB does not support directly querying a writable external table. To query the data that you just added to HDFS, you must create a readable external SynxDB table that references the HDFS directory:</p>
<pre><code class="language-sql">postgres=# CREATE EXTERNAL TABLE pxf_hdfs_textsimple_r1(location text, month text, num_orders int, total_sales float8)
            LOCATION ('pxf://data/pxf_examples/pxfwritable_hdfs_textsimple1?PROFILE=hdfs:text')
		    FORMAT 'CSV';
</code></pre>
<p>You specify the <code>'CSV'</code> <code>FORMAT</code> when you create the readable external table because you created the writable table with a comma (<code>,</code>) as the delimiter character, the default delimiter for <code>'CSV'</code> <code>FORMAT</code>.</p>
</li>
<li>
<p>Query the readable external table:</p>
<pre><code class="language-sql">postgres=# SELECT * FROM pxf_hdfs_textsimple_r1 ORDER BY total_sales;
</code></pre>
<pre><code class="language-pre"> location  | month | num_orders | total_sales 
-----------+-------+------------+-------------
 Rome      | Mar   |         87 |     1557.39
 Frankfurt | Mar   |        777 |     3956.98
 Prague    | Jan   |        101 |     4875.33
 Bangalore | May   |        317 |     8936.99
 Beijing   | Jul   |        411 |    11600.67
 Cleveland | Oct   |       3812 |    96645.37
(6 rows)
</code></pre>
<p>The <code>pxf_hdfs_textsimple_r1</code> table includes the records you individually inserted, as well as the full contents of the <code>pxf_hdfs_textsimple</code> table if you performed the optional step.</p>
</li>
<li>
<p>Create a second SynxDB writable external table, this time using Gzip compression and employing a colon <code>:</code> as the delimiter:</p>
<pre><code class="language-sql">postgres=# CREATE WRITABLE EXTERNAL TABLE pxf_hdfs_writabletbl_2 (location text, month text, num_orders int, total_sales float8)
            LOCATION ('pxf://data/pxf_examples/pxfwritable_hdfs_textsimple2?PROFILE=hdfs:text&amp;COMPRESSION_CODEC=gzip')
          FORMAT 'TEXT' (delimiter=':');
</code></pre>
</li>
<li>
<p>Write a few records to the <code>pxfwritable_hdfs_textsimple2</code> HDFS directory by inserting directly into the <code>pxf_hdfs_writabletbl_2</code> table:</p>
<pre><code class="language-sql">gpadmin=# INSERT INTO pxf_hdfs_writabletbl_2 VALUES ( 'Frankfurt', 'Mar', 777, 3956.98 );
gpadmin=# INSERT INTO pxf_hdfs_writabletbl_2 VALUES ( 'Cleveland', 'Oct', 3812, 96645.37 );
</code></pre>
</li>
<li>
<p>In another terminal window, display the contents of the data that you added to HDFS; use the <code>-text</code> option to <code>hdfs dfs</code> to view the compressed data as text:</p>
<pre><code class="language-shell">$ hdfs dfs -text /data/pxf_examples/pxfwritable_hdfs_textsimple2/*
Frankfurt:Mar:777:3956.98
Cleveland:Oct:3812:96645.3
</code></pre>
<p>Notice that the colon <code>:</code> is the field separator in this HDFS data.</p>
<p>To query data from the newly-created HDFS directory named <code>pxfwritable_hdfs_textsimple2</code>, you can create a readable external SynxDB table as described above that references this HDFS directory and specifies <code>FORMAT 'CSV' (delimiter=':')</code>.</p>
</li>
</ol>
<h2 id="about-setting-the-external-table-encoding"><a class="header" href="#about-setting-the-external-table-encoding"><a id="about_encoding"></a>About Setting the External Table Encoding</a></h2>
<p>When the external file encoding differs from the database encoding, you must set the external table <code>ENCODING</code> to match that of the data file. For example, if the database encoding is <code>UTF8</code> and the file encoding is <code>LATIN1</code>, create the external table as follows:</p>
<pre><code>CREATE EXTERNAL TABLE pxf_csv_latin1(location text, month text, num_orders int, total_sales float8)
  LOCATION ('pxf://data/pxf_examples/pxf_hdfs_simple.txt?PROFILE=hdfs:csv')
FORMAT 'CSV' ENCODING 'LATIN1';
</code></pre>
<h2 id="about-reading-data-containing-multi-byte-or-multi-character-delimiters"><a class="header" href="#about-reading-data-containing-multi-byte-or-multi-character-delimiters"><a id="multibyte_delim"></a>About Reading Data Containing Multi-Byte or Multi-Character Delimiters</a></h2>
<p>You can use only a <code>*:csv</code> PXF profile to read data that contains a multi-byte delimiter or multiple delimiter characters. The syntax for creating a readable external table for such data follows:</p>
<pre><code class="language-sql">CREATE EXTERNAL TABLE &lt;table_name&gt;
    ( &lt;column_name&gt; &lt;data_type&gt; [, ...] | LIKE &lt;other_table&gt; )
LOCATION ('pxf://&lt;path-to-hdfs-file&gt;?PROFILE=hdfs:csv[&amp;SERVER=&lt;server_name&gt;][&amp;IGNORE_MISSING_PATH=&lt;boolean&gt;][&amp;SKIP_HEADER_COUNT=&lt;numlines&gt;][&amp;NEWLINE=&lt;bytecode&gt;]')
FORMAT 'CUSTOM' (FORMATTER='pxfdelimited_import' &lt;option&gt;[=|&lt;space&gt;][E]'&lt;value&gt;');
</code></pre>
<p>Note the <code>FORMAT</code> line in the syntax block. While the syntax is similar to that of reading CSV, PXF requires a custom formatter to read data containing a multi-byte or multi-character delimiter. You must specify the <code>'CUSTOM'</code> format and the <code>pxfdelimited_import</code> formatter. You must also specify a delimiter in the formatter options.</p>
<p>PXF recognizes the following formatter options when reading data that contains a multi-byte or multi-character delimiter:</p>
<div class="table-wrapper"><table><thead><tr><th>Option Name</th><th>Value Description</th><th>Default Value</th></tr></thead><tbody>
<tr><td>DELIMITER=&lt;delim_string&gt;</td><td>The single-byte or multi-byte delimiter string that separates columns. The string may be up to 32 bytes in length, and may not contain quote or escape characters. <strong>Required</strong></td><td>None</td></tr>
<tr><td>QUOTE=&lt;char&gt;</td><td>The single one-byte ASCII quotation character for all columns.</td><td>None</td></tr>
<tr><td>ESCAPE=&lt;char&gt;</td><td>The single one-byte ASCII character used to escape special characters (for example, the <code>DELIM</code>, <code>QUOTE</code>,  or <code>NEWLINE</code> value, or the <code>ESCAPE</code> value itself).</td><td>None, or the <code>QUOTE</code> value if that is set</td></tr>
<tr><td>NEWLINE=&lt;bytecode&gt;</td><td>The end-of-line indicator that designates the end of a row. Valid values are <code>LF</code> (line feed), <code>CR</code> (carriage return), or <code>CRLF</code> (carriage return plus line feed.</td><td><code>LF</code></td></tr>
</tbody></table>
</div>
<p>The following sections provide further information about, and examples for, specifying the delimiter, quote, escape, and new line options.</p>
<h3 id="specifying-the-delimiter"><a class="header" href="#specifying-the-delimiter"><a id="about_delim"></a>Specifying the Delimiter</a></h3>
<p>You must directly specify the delimiter or provide its byte representation. For example, given the following sample data that uses a <code>¤</code> currency symbol delimiter:</p>
<pre><code>133¤Austin¤USA
321¤Boston¤USA
987¤Paris¤France
</code></pre>
<p>Create the external table as follows:</p>
<pre><code>CREATE READABLE EXTERNAL TABLE mbyte_delim (id int, city text, country text)
  LOCATION ('pxf://multibyte_currency?PROFILE=hdfs:csv')
FORMAT 'CUSTOM' (FORMATTER='pxfdelimited_import', DELIMITER='¤'); 
</code></pre>
<h4 id="about-specifying-the-byte-representation-of-the-delimiter"><a class="header" href="#about-specifying-the-byte-representation-of-the-delimiter"><a id="delim_byterep"></a>About Specifying the Byte Representation of the Delimiter</a></h4>
<p>You can directly specify the delimiter or provide its byte representation. If you choose to specify the byte representation of the delimiter:</p>
<ul>
<li>You must specify the byte representation of the delimiter in <code>E'&lt;value&gt;'</code> format.</li>
<li>Because some characters have different byte representations in different encodings, you must specify the byte representation of the delimiter in the <em>database encoding</em>.</li>
</ul>
<p>For example, if the database encoding is <code>UTF8</code>, the file encoding is <code>LATIN1</code>, and the delimiter is the <code>¤</code> currency symbol, you must specify the <code>UTF8</code> byte representation for <code>¤</code>, which is <code>\xC2\xA4</code>:</p>
<pre><code>CREATE READABLE EXTERNAL TABLE byterep_delim (id int, city text, country text)
  LOCATION ('pxf://multibyte_example?PROFILE=hdfs:csv')
FORMAT 'CUSTOM' (FORMATTER='pxfdelimited_import', DELIMITER=E'\xC2\xA4') ENCODING 'LATIN1';
</code></pre>
<h3 id="about-specifying-quote-and-escape-characters"><a class="header" href="#about-specifying-quote-and-escape-characters"><a id="about_qe"></a>About Specifying Quote and Escape Characters</a></h3>
<p>When PXF reads data that contains a multi-byte or multi-character delimiter, its behavior depends on the quote and escape character settings:</p>
<div class="table-wrapper"><table><thead><tr><th>QUOTE Set?</th><th>ESCAPE Set?</th><th>PXF Behaviour</th></tr></thead><tbody>
<tr><td>No<sup>1</sup></td><td>No</td><td>PXF reads the data as-is.</td></tr>
<tr><td>Yes<sup>2</sup></td><td>Yes</td><td>PXF reads the data between quote characters as-is and un-escapes only the quote and escape characters.</td></tr>
<tr><td>Yes<sup>2</sup></td><td>No (<code>ESCAPE 'OFF'</code>)</td><td>PXF reads the data between quote characters as-is.</td></tr>
<tr><td>No<sup>1</sup></td><td>Yes</td><td>PXF reads the data as-is and un-escapes only the delimiter, newline, and escape itself.</td></tr>
</tbody></table>
</div>
<p><sup>1</sup> All data columns must be un-quoted when you do not specify a quote character.</p>
<p><sup>2</sup> All data columns must quoted when you specify a quote character.</p>
<blockquote>
<p><strong>Note</strong> PXF expects that there are no extraneous characters between the quote value and the delimiter value, nor between the quote value and the end-of-line value. Additionally, there must be no white space between delimiters and quotes.</p>
</blockquote>
<h3 id="about-the-newline-options"><a class="header" href="#about-the-newline-options"><a id="about_newline"></a>About the NEWLINE Options</a></h3>
<p>PXF requires that every line in the file be terminated with the same new line value.</p>
<p>By default, PXF uses the line feed character (<code>LF</code>) for the new line delimiter. When the new line delimiter for the external file is also a line feed, you need not specify the <code>NEWLINE</code> formatter option.</p>
<p>If the <code>NEWLINE</code> formatter option is provided and contains <code>CR</code> or <code>CRLF</code>, you must also specify the same <code>NEWLINE</code> option in the external table <code>LOCATION</code> URI. For example, if the new line delimiter is <code>CRLF</code>, create the external table as follows:</p>
<pre><code>CREATE READABLE EXTERNAL TABLE mbyte_newline_crlf (id int, city text, country text)
  LOCATION ('pxf://multibyte_example_crlf?PROFILE=hdfs:csv&amp;NEWLINE=CRLF')
FORMAT 'CUSTOM' (FORMATTER='pxfdelimited_import', DELIMITER='¤', NEWLINE='CRLF');
</code></pre>
<h3 id="examples"><a class="header" href="#examples"><a id="mbd_examples"></a>Examples</a></h3>
<h4 id="delimiter-with-quoted-data"><a class="header" href="#delimiter-with-quoted-data"><a id="qe_example"></a>Delimiter with Quoted Data</a></h4>
<p>Given the following sample data that uses the double-quote (<code>"</code>) quote character and the delimiter <code>¤</code>:</p>
<pre><code>"133"¤"Austin"¤"USA"
"321"¤"Boston"¤"USA"
"987"¤"Paris"¤"France"
</code></pre>
<p>Create the external table as follows:</p>
<pre><code>CREATE READABLE EXTERNAL TABLE mbyte_delim_quoted (id int, city text, country text)
  LOCATION ('pxf://multibyte_q?PROFILE=hdfs:csv')
FORMAT 'CUSTOM' (FORMATTER='pxfdelimited_import', DELIMITER='¤', QUOTE '"'); 
</code></pre>
<h4 id="delimiter-with-quoted-and-escaped-data"><a class="header" href="#delimiter-with-quoted-and-escaped-data"><a id="qe_example"></a>Delimiter with Quoted and Escaped Data</a></h4>
<p>Given the following sample data that uses the quote character <code>"</code>, the escape character <code>\</code>, and the delimiter <code>¤</code>:</p>
<pre><code>"\"hello, my name is jane\" she said. let's escape something \\"¤"123"
</code></pre>
<p>Create the external table as follows:</p>
<pre><code>CREATE READABLE EXTERNAL TABLE mybte_delim_quoted_escaped (sentence text, num int)
  LOCATION ('pxf://multibyte_qe?PROFILE=hdfs:csv')
FORMAT 'CUSTOM' (FORMATTER='pxfdelimited_import', DELIMITER='¤', QUOTE '"', ESCAPE '\');
</code></pre>
<p>With this external table definition, PXF reads the <code>sentence</code> text field as:</p>
<pre><code>SELECT sentence FROM mbyte_delim_quoted_escaped;

                          sentence 
-------------------------------------------------------------
 "hello, my name is jane" she said. let's escape something \
(1 row)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../pxf/access_hdfs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../pxf/hdfs_fixedwidth.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../pxf/access_hdfs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../pxf/hdfs_fixedwidth.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
