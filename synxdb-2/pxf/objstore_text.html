<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Reading and Writing Text Data - SynxDB 2 Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SynxDB 2 Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                        &nbsp;&nbsp;&nbsp;&nbsp;
                        <a href="https://www.synxdata.com/"><img id="fa fa-print" src="../SYNX-Text-and-Circular-Logo-142x28-White-text-Black-background.png" alt="Synx Data Labs Logo"/></a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="reading-and-writing-text-data-in-an-object-store"><a class="header" href="#reading-and-writing-text-data-in-an-object-store">Reading and Writing Text Data in an Object Store</a></h1>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->
<p>The PXF object store connectors support plain delimited and comma-separated value format text data. This section describes how to use PXF to access text data in an object store, including how to create, query, and insert data into an external table that references files in the object store.</p>
<p><strong>Note</strong>: Accessing text data from an object store is very similar to accessing text data in HDFS.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites"><a id="prereq"></a>Prerequisites</a></h2>
<p>Ensure that you have met the PXF Object Store <a href="access_objstore.html#objstore_prereq">Prerequisites</a> before you attempt to read data from or write data to an object store.</p>
<h2 id="reading-text-data"><a class="header" href="#reading-text-data"><a id="profile_text"></a>Reading Text Data</a></h2>
<p>Use the <code>&lt;objstore&gt;:text</code> profile when you read plain text delimited and <code>&lt;objstore&gt;:csv</code> when reading .csv data from an object store where each row is a single record.  PXF supports the following <code>&lt;objstore&gt;</code> profile prefixes:</p>
<div class="table-wrapper"><table><thead><tr><th>Object Store</th><th>Profile Prefix</th></tr></thead><tbody>
<tr><td>Azure Blob Storage</td><td>wasbs</td></tr>
<tr><td>Azure Data Lake Storage Gen2</td><td>abfss</td></tr>
<tr><td>Google Cloud Storage</td><td>gs</td></tr>
<tr><td>MinIO</td><td>s3</td></tr>
<tr><td>S3</td><td>s3</td></tr>
</tbody></table>
</div>
<p>The following syntax creates a SynxDB readable external table that references a simple text file in an object store: </p>
<pre><code class="language-sql">CREATE EXTERNAL TABLE &lt;table_name&gt; 
    ( &lt;column_name&gt; &lt;data_type&gt; [, ...] | LIKE &lt;other_table&gt; )
LOCATION ('pxf://&lt;path-to-file&gt;?PROFILE=&lt;objstore&gt;:text|csv&amp;SERVER=&lt;server_name&gt;[&amp;IGNORE_MISSING_PATH=&lt;boolean&gt;][&amp;SKIP_HEADER_COUNT=&lt;numlines&gt;][&amp;&lt;custom-option&gt;=&lt;value&gt;[...]]')
FORMAT '[TEXT|CSV]' (delimiter[=|&lt;space&gt;][E]'&lt;delim_value&gt;');
</code></pre>
<p>The specific keywords and values used in the SynxDB <a href="../ref_guide/sql_commands/CREATE_EXTERNAL_TABLE.html">CREATE EXTERNAL TABLE</a> command are described in the table below.</p>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th>Value</th></tr></thead><tbody>
<tr><td>&lt;path‑to‑file&gt;</td><td>The path to the directory or file in the object store. When the <code>&lt;server_name&gt;</code> configuration includes a <a href="cfg_server.html#pxf-fs-basepath"><code>pxf.fs.basePath</code></a> property setting, PXF considers &lt;path‑to‑file&gt; to be relative to the base path specified. Otherwise, PXF considers it to be an absolute path. &lt;path‑to‑file&gt; must not specify a relative path nor include the dollar sign (<code>$</code>) character.</td></tr>
<tr><td>PROFILE=&lt;objstore&gt;:text<br> PROFILE=&lt;objstore&gt;:csv</td><td>The <code>PROFILE</code> keyword must identify the specific object store. For example, <code>s3:text</code>.</td></tr>
<tr><td>SERVER=&lt;server_name&gt;</td><td>The named server configuration that PXF uses to access the data.</td></tr>
<tr><td>IGNORE_MISSING_PATH=&lt;boolean&gt;</td><td>Specify the action to take when &lt;path-to-file&gt; is missing or invalid. The default value is <code>false</code>, PXF returns an error in this situation. When the value is <code>true</code>, PXF ignores missing path errors and returns an empty fragment.</td></tr>
<tr><td>SKIP_HEADER_COUNT=&lt;numlines&gt;</td><td>Specify the number of header lines that PXF should skip in the first split of each &lt;file&gt; before reading the data. The default value is 0, do not skip any lines.</td></tr>
<tr><td>FORMAT</td><td>Use <code>FORMAT</code> <code>'TEXT'</code> when &lt;path-to-file&gt; references plain text delimited data.<br> Use <code>FORMAT</code> <code>'CSV'</code>  when &lt;path-to-file&gt; references comma-separated value data.</td></tr>
<tr><td>delimiter</td><td>The delimiter character in the data. For <code>FORMAT</code> <code>'CSV'</code>, the default &lt;delim_value&gt; is a comma (<code>,</code>). Preface the &lt;delim_value&gt; with an <code>E</code> when the value is an escape sequence. Examples: <code>(delimiter=E'\t')</code>, <code>(delimiter ':')</code>.</td></tr>
</tbody></table>
</div>
<p><strong>Note</strong>: PXF does not support the <code>(HEADER)</code> formatter option in the <code>CREATE EXTERNAL TABLE</code> command. If your text file includes header line(s), use <code>SKIP_HEADER_COUNT</code> to specify the number of lines that PXF should skip at the beginning of the first split of each file.</p>
<p>If you are accessing an S3 object store:</p>
<ul>
<li>
<p>You can provide S3 credentials via custom options in the <code>CREATE EXTERNAL TABLE</code> command as described in <a href="access_s3.html#s3_override">Overriding the S3 Server Configuration with DDL</a>.</p>
</li>
<li>
<p>If you are reading CSV-format data from S3, you can direct PXF to use the S3 Select Amazon service to retrieve the data. Refer to <a href="access_s3.html#s3_select">Using the Amazon S3 Select Service</a> for more information about the PXF custom option used for this purpose.</p>
</li>
</ul>
<h3 id="example-reading-text-data-from-s3"><a class="header" href="#example-reading-text-data-from-s3"><a id="profile_text_query"></a>Example: Reading Text Data from S3</a></h3>
<p>Perform the following procedure to create a sample text file, copy the file to S3, and use the <code>s3:text</code> and <code>s3:csv</code> profiles to create two PXF external tables to query the data.</p>
<p>To run this example, you must:</p>
<ul>
<li>Have the AWS CLI tools installed on your system</li>
<li>Know your AWS access ID and secret key</li>
<li>Have write permission to an S3 bucket</li>
</ul>
<ol>
<li>
<p>Create a directory in S3 for PXF example data files. For example, if you have write access to an S3 bucket named <code>BUCKET</code>:</p>
<pre><code class="language-shell">$ aws s3 mb s3://BUCKET/pxf_examples
</code></pre>
</li>
<li>
<p>Locally create a delimited plain text data file named <code>pxf_s3_simple.txt</code>:</p>
<pre><code class="language-shell">$ echo 'Prague,Jan,101,4875.33
Rome,Mar,87,1557.39
Bangalore,May,317,8936.99
Beijing,Jul,411,11600.67' &gt; /tmp/pxf_s3_simple.txt
</code></pre>
<p>Note the use of the comma (<code>,</code>) to separate the four data fields.</p>
</li>
<li>
<p>Copy the data file to the S3 directory you created in Step 1:</p>
<pre><code class="language-shell">$ aws s3 cp /tmp/pxf_s3_simple.txt s3://BUCKET/pxf_examples/
</code></pre>
</li>
<li>
<p>Verify that the file now resides in S3:</p>
<pre><code class="language-shell">$ aws s3 ls s3://BUCKET/pxf_examples/pxf_s3_simple.txt
</code></pre>
</li>
<li>
<p>Start the <code>psql</code> subsystem:</p>
<pre><code class="language-shell">$ psql -d postgres
</code></pre>
</li>
<li>
<p>Use the PXF <code>s3:text</code> profile to create a SynxDB external table that references the <code>pxf_s3_simple.txt</code> file that you just created and added to S3. For example, if your server name is <code>s3srvcfg</code>:</p>
<pre><code class="language-sql">postgres=# CREATE EXTERNAL TABLE pxf_s3_textsimple(location text, month text, num_orders int, total_sales float8)
            LOCATION ('pxf://BUCKET/pxf_examples/pxf_s3_simple.txt?PROFILE=s3:text&amp;SERVER=s3srvcfg')
          FORMAT 'TEXT' (delimiter=E',');
</code></pre>
</li>
<li>
<p>Query the external table:</p>
<pre><code class="language-sql">postgres=# SELECT * FROM pxf_s3_textsimple;          
</code></pre>
<pre><code class="language-pre">   location    | month | num_orders | total_sales 
---------------+-------+------------+-------------
 Prague        | Jan   |        101 |     4875.33
 Rome          | Mar   |         87 |     1557.39
 Bangalore     | May   |        317 |     8936.99
 Beijing       | Jul   |        411 |    11600.67
(4 rows)
</code></pre>
</li>
<li>
<p>Create a second external table that references <code>pxf_s3_simple.txt</code>, this time specifying the <code>s3:csv</code> <code>PROFILE</code> and the <code>CSV</code> <code>FORMAT</code>:</p>
<pre><code class="language-sql">postgres=# CREATE EXTERNAL TABLE pxf_s3_textsimple_csv(location text, month text, num_orders int, total_sales float8)
            LOCATION ('pxf://BUCKET/pxf_examples/pxf_s3_simple.txt?PROFILE=s3:csv&amp;SERVER=s3srvcfg')
          FORMAT 'CSV';
postgres=# SELECT * FROM pxf_s3_textsimple_csv;          
</code></pre>
<p>When you specify <code>FORMAT 'CSV'</code> for comma-separated value data, no <code>delimiter</code> formatter option is required because comma is the default delimiter value.</p>
</li>
</ol>
<h2 id="reading-text-data-with-quoted-linefeeds"><a class="header" href="#reading-text-data-with-quoted-linefeeds"><a id="profile_textmulti"></a>Reading Text Data with Quoted Linefeeds</a></h2>
<p>Use the <code>&lt;objstore&gt;:text:multi</code> profile to read plain text data with delimited single- or multi- line records that include embedded (quoted) linefeed characters. The following syntax creates a SynxDB readable external table that references such a text file in an object store:</p>
<pre><code class="language-sql">CREATE EXTERNAL TABLE &lt;table_name&gt;
    ( &lt;column_name&gt; &lt;data_type&gt; [, ...] | LIKE &lt;other_table&gt; )
LOCATION ('pxf://&lt;path-to-file&gt;?PROFILE=&lt;objstore&gt;:text:multi&amp;SERVER=&lt;server_name&gt;[&amp;IGNORE_MISSING_PATH=&lt;boolean&gt;][&amp;SKIP_HEADER_COUNT=&lt;numlines&gt;][&amp;&lt;custom-option&gt;=&lt;value&gt;[...]]')
FORMAT '[TEXT|CSV]' (delimiter[=|&lt;space&gt;][E]'&lt;delim_value&gt;');
</code></pre>
<p>The specific keywords and values used in the <a href="../ref_guide/sql_commands/CREATE_EXTERNAL_TABLE.html">CREATE EXTERNAL TABLE</a> command are described in the table below.</p>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th>Value</th></tr></thead><tbody>
<tr><td>&lt;path‑to‑file&gt;</td><td>The path to the directory or file in the data store. When the <code>&lt;server_name&gt;</code> configuration includes a <a href="cfg_server.html#pxf-fs-basepath"><code>pxf.fs.basePath</code></a> property setting, PXF considers &lt;path‑to‑file&gt; to be relative to the base path specified. Otherwise, PXF considers it to be an absolute path. &lt;path‑to‑file&gt; must not specify a relative path nor include the dollar sign (<code>$</code>) character.</td></tr>
<tr><td>PROFILE=&lt;objstore&gt;:text:multi</td><td>The <code>PROFILE</code> keyword must identify the specific object store. For example, <code>s3:text:multi</code>.</td></tr>
<tr><td>SERVER=&lt;server_name&gt;</td><td>The named server configuration that PXF uses to access the data.</td></tr>
<tr><td>IGNORE_MISSING_PATH=&lt;boolean&gt;</td><td>Specify the action to take when &lt;path-to-file&gt; is missing or invalid. The default value is <code>false</code>, PXF returns an error in this situation. When the value is <code>true</code>, PXF ignores missing path errors and returns an empty fragment.</td></tr>
<tr><td>SKIP_HEADER_COUNT=&lt;numlines&gt;</td><td>Specify the number of header lines that PXF should skip in the first split of each &lt;file&gt; before reading the data. The default value is 0, do not skip any lines.</td></tr>
<tr><td>FORMAT</td><td>Use <code>FORMAT</code> <code>'TEXT'</code> when &lt;path-to-file&gt; references plain text delimited data.<br> Use <code>FORMAT</code> <code>'CSV'</code> when &lt;path-to-file&gt; references comma-separated value data.</td></tr>
<tr><td>delimiter</td><td>The delimiter character in the data. For <code>FORMAT</code> <code>'CSV'</code>, the default &lt;delim_value&gt; is a comma (<code>,</code>). Preface the &lt;delim_value&gt; with an <code>E</code> when the value is an escape sequence. Examples: <code>(delimiter=E'\t')</code>, <code>(delimiter ':')</code>.</td></tr>
</tbody></table>
</div>
<p><strong>Note</strong>: PXF does not support the <code>(HEADER)</code> formatter option in the <code>CREATE EXTERNAL TABLE</code> command. If your text file includes header line(s), use <code>SKIP_HEADER_COUNT</code> to specify the number of lines that PXF should skip at the beginning of the first split of each file.</p>
<p>If you are accessing an S3 object store, you can provide S3 credentials via custom options in the <code>CREATE EXTERNAL TABLE</code> command as described in <a href="access_s3.html#s3_override">Overriding the S3 Server Configuration with DDL</a>.</p>
<h3 id="example-reading-multi-line-text-data-from-s3"><a class="header" href="#example-reading-multi-line-text-data-from-s3"><a id="profile_textmulti_query"></a>Example: Reading Multi-Line Text Data from S3</a></h3>
<p>Perform the following steps to create a sample text file, copy the file to S3, and use the PXF <code>s3:text:multi</code> profile to create a SynxDB readable external table to query the data.</p>
<p>To run this example, you must:</p>
<ul>
<li>Have the AWS CLI tools installed on your system</li>
<li>Know your AWS access ID and secret key</li>
<li>Have write permission to an S3 bucket</li>
</ul>
<ol>
<li>
<p>Create a second delimited plain text file:</p>
<pre><code class="language-shell">$ vi /tmp/pxf_s3_multi.txt
</code></pre>
</li>
<li>
<p>Copy/paste the following data into <code>pxf_s3_multi.txt</code>:</p>
<pre><code class="language-pre">"4627 Star Rd.
San Francisco, CA  94107":Sept:2017
"113 Moon St.
San Diego, CA  92093":Jan:2018
"51 Belt Ct.
Denver, CO  90123":Dec:2016
"93114 Radial Rd.
Chicago, IL  60605":Jul:2017
"7301 Brookview Ave.
Columbus, OH  43213":Dec:2018
</code></pre>
<p>Notice the use of the colon <code>:</code> to separate the three fields. Also notice the quotes around the first (address) field. This field includes an embedded line feed separating the street address from the city and state.</p>
</li>
<li>
<p>Copy the text file to S3:</p>
<pre><code class="language-shell">$ aws s3 cp /tmp/pxf_s3_multi.txt s3://BUCKET/pxf_examples/
</code></pre>
</li>
<li>
<p>Use the <code>s3:text:multi</code> profile to create an external table that references the <code>pxf_s3_multi.txt</code> S3 file, making sure to identify the <code>:</code> (colon) as the field separator. For example, if your server name is <code>s3srvcfg</code>:</p>
<pre><code class="language-sql">postgres=# CREATE EXTERNAL TABLE pxf_s3_textmulti(address text, month text, year int)
            LOCATION ('pxf://BUCKET/pxf_examples/pxf_s3_multi.txt?PROFILE=s3:text:multi&amp;SERVER=s3srvcfg')
          FORMAT 'CSV' (delimiter ':');
</code></pre>
<p>Notice the alternate syntax for specifying the <code>delimiter</code>.</p>
</li>
<li>
<p>Query the <code>pxf_s3_textmulti</code> table:</p>
<pre><code class="language-sql">postgres=# SELECT * FROM pxf_s3_textmulti;
</code></pre>
<pre><code class="language-pre">         address          | month | year 
--------------------------+-------+------
 4627 Star Rd.            | Sept  | 2017
 San Francisco, CA  94107           
 113 Moon St.             | Jan   | 2018
 San Diego, CA  92093               
 51 Belt Ct.              | Dec   | 2016
 Denver, CO  90123                  
 93114 Radial Rd.         | Jul   | 2017
 Chicago, IL  60605                 
 7301 Brookview Ave.      | Dec   | 2018
 Columbus, OH  43213                
(5 rows)
</code></pre>
</li>
</ol>
<h2 id="writing-text-data"><a class="header" href="#writing-text-data"><a id="write_text"></a>Writing Text Data</a></h2>
<p>The <code>&lt;objstore&gt;:text|csv</code> profiles support writing single line plain text data to an object store. When you create a writable external table with PXF, you specify the name of a directory. When you insert records into a writable external table, the block(s) of data that you insert are written to one or more files in the directory that you specified.</p>
<p><strong>Note</strong>: External tables that you create with a writable profile can only be used for <code>INSERT</code> operations. If you want to query the data that you inserted, you must create a separate readable external table that references the directory.</p>
<p>Use the following syntax to create a SynxDB writable external table that references an object store directory: </p>
<pre><code class="language-sql">CREATE WRITABLE EXTERNAL TABLE &lt;table_name&gt; 
    ( &lt;column_name&gt; &lt;data_type&gt; [, ...] | LIKE &lt;other_table&gt; )
LOCATION ('pxf://&lt;path-to-dir&gt;
    ?PROFILE=&lt;objstore&gt;:text|csv&amp;SERVER=&lt;server_name&gt;[&amp;&lt;custom-option&gt;=&lt;value&gt;[...]]')
FORMAT '[TEXT|CSV]' (delimiter[=|&lt;space&gt;][E]'&lt;delim_value&gt;');
[DISTRIBUTED BY (&lt;column_name&gt; [, ... ] ) | DISTRIBUTED RANDOMLY];
</code></pre>
<p>The specific keywords and values used in the <a href="../ref_guide/sql_commands/CREATE_EXTERNAL_TABLE.html">CREATE EXTERNAL TABLE</a> command are described in the table below.</p>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th>Value</th></tr></thead><tbody>
<tr><td>&lt;path‑to‑dir&gt;</td><td>The path to the directory in the data store. When the <code>&lt;server_name&gt;</code> configuration includes a <a href="cfg_server.html#pxf-fs-basepath"><code>pxf.fs.basePath</code></a> property setting, PXF considers &lt;path‑to‑dir&gt; to be relative to the base path specified. Otherwise, PXF considers it to be an absolute path. &lt;path‑to‑dir&gt; must not specify a relative path nor include the dollar sign (<code>$</code>) character.</td></tr>
<tr><td>PROFILE=&lt;objstore&gt;:text<br> PROFILE=&lt;objstore&gt;:csv</td><td>The <code>PROFILE</code> keyword must identify the specific object store. For example, <code>s3:text</code>.</td></tr>
<tr><td>SERVER=&lt;server_name&gt;</td><td>The named server configuration that PXF uses to access the data.</td></tr>
<tr><td>&lt;custom‑option&gt;=&lt;value&gt;</td><td>&lt;custom-option&gt;s are described below.</td></tr>
<tr><td>FORMAT</td><td>Use <code>FORMAT</code> <code>'TEXT'</code> to write plain, delimited text to &lt;path-to-dir&gt;.<br> Use <code>FORMAT</code> <code>'CSV'</code> to write comma-separated value text to &lt;path-to-dir&gt;.</td></tr>
<tr><td>delimiter</td><td>The delimiter character in the data. For <code>FORMAT</code> <code>'CSV'</code>, the default &lt;delim_value&gt; is a comma (<code>,</code>). Preface the &lt;delim_value&gt; with an <code>E</code> when the value is an escape sequence. Examples: <code>(delimiter=E'\t')</code>, <code>(delimiter ':')</code>.</td></tr>
<tr><td>DISTRIBUTED BY</td><td>If you want to load data from an existing SynxDB table into the writable external table, consider specifying the same distribution policy or <code>&lt;column_name&gt;</code> on both tables. Doing so will avoid extra motion of data between segments on the load operation.</td></tr>
</tbody></table>
</div>
<p>Writable external tables that you create using an <code>&lt;objstore&gt;:text|csv</code> profile can optionally use record or block compression. You specify the compression codec via a custom option in the <code>CREATE EXTERNAL TABLE</code> <code>LOCATION</code> clause. The <code>&lt;objstore&gt;:text|csv</code> profiles support the following custom write options:</p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Value Description</th></tr></thead><tbody>
<tr><td>COMPRESSION_CODEC</td><td>The compression codec alias. Supported compression codecs for writing text data include: <code>default</code>, <code>bzip2</code>, <code>gzip</code>, and <code>uncompressed</code>. If this option is not provided, SynxDB performs no data compression.</td></tr>
</tbody></table>
</div>
<p>If you are accessing an S3 object store, you can provide S3 credentials via custom options in the <code>CREATE EXTERNAL TABLE</code> command as described in <a href="access_s3.html#s3_override">Overriding the S3 Server Configuration with DDL</a>.</p>
<h3 id="example-writing-text-data-to-s3"><a class="header" href="#example-writing-text-data-to-s3"><a id="write_s3textsimple_example"></a>Example: Writing Text Data to S3</a></h3>
<p>This example utilizes the data schema introduced in <a href="#profile_text_query">Example: Reading Text Data from S3</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>Column Name</th><th>Data Type</th></tr></thead><tbody>
<tr><td>location</td><td>text</td></tr>
<tr><td>month</td><td>text</td></tr>
<tr><td>number_of_orders</td><td>int</td></tr>
<tr><td>total_sales</td><td>float8</td></tr>
</tbody></table>
</div>
<p>This example also optionally uses the SynxDB external table named <code>pxf_s3_textsimple</code> that you created in that exercise.</p>
<h4 id="procedure"><a class="header" href="#procedure"><a id="write_s3textsimple_proc" class="no-quick-link"></a>Procedure</a></h4>
<p>Perform the following procedure to create SynxDB writable external tables utilizing the same data schema as described above, one of which will employ compression. You will use the PXF <code>s3:text</code> profile to write data to S3. You will also create a separate, readable external table to read the data that you wrote to S3.</p>
<ol>
<li>
<p>Create a SynxDB writable external table utilizing the data schema described above. Write to the S3 directory <code>BUCKET/pxf_examples/pxfwrite_s3_textsimple1</code>. Create the table specifying a comma (<code>,</code>) as the delimiter. For example, if your server name is <code>s3srvcfg</code>:</p>
<pre><code class="language-sql">postgres=# CREATE WRITABLE EXTERNAL TABLE pxf_s3_writetbl_1(location text, month text, num_orders int, total_sales float8)
            LOCATION ('pxf://BUCKET/pxf_examples/pxfwrite_s3_textsimple1?PROFILE=s3:text|csv&amp;SERVER=s3srvcfg')
          FORMAT 'TEXT' (delimiter=',');
</code></pre>
<p>You specify the <code>FORMAT</code> subclause <code>delimiter</code> value as the single ascii comma character <code>,</code>.</p>
</li>
<li>
<p>Write a few individual records to the <code>pxfwrite_s3_textsimple1</code> S3 directory by invoking the SQL <code>INSERT</code> command on <code>pxf_s3_writetbl_1</code>:</p>
<pre><code class="language-sql">postgres=# INSERT INTO pxf_s3_writetbl_1 VALUES ( 'Frankfurt', 'Mar', 777, 3956.98 );
postgres=# INSERT INTO pxf_s3_writetbl_1 VALUES ( 'Cleveland', 'Oct', 3812, 96645.37 );
</code></pre>
</li>
<li>
<p>(Optional) Insert the data from the <code>pxf_s3_textsimple</code> table that you created in [Example: Reading Text Data from S3] (#profile_text_query) into <code>pxf_s3_writetbl_1</code>:</p>
<pre><code class="language-sql">postgres=# INSERT INTO pxf_s3_writetbl_1 SELECT * FROM pxf_s3_textsimple;
</code></pre>
</li>
<li>
<p>SynxDB does not support directly querying a writable external table. To query the data that you just added to S3, you must create a readable external SynxDB table that references the S3 directory:</p>
<pre><code class="language-sql">postgres=# CREATE EXTERNAL TABLE pxf_s3_textsimple_r1(location text, month text, num_orders int, total_sales float8)
            LOCATION ('pxf://BUCKET/pxf_examples/pxfwrite_s3_textsimple1?PROFILE=s3:text&amp;SERVER=s3srvcfg')
		    FORMAT 'CSV';
</code></pre>
<p>You specify the <code>'CSV'</code> <code>FORMAT</code> when you create the readable external table because you created the writable table with a comma (<code>,</code>) as the delimiter character, the default delimiter for <code>'CSV'</code> <code>FORMAT</code>.</p>
</li>
<li>
<p>Query the readable external table:</p>
<pre><code class="language-sql">postgres=# SELECT * FROM pxf_s3_textsimple_r1 ORDER BY total_sales;
</code></pre>
<pre><code class="language-pre"> location  | month | num_orders | total_sales 
-----------+-------+------------+-------------
 Rome      | Mar   |         87 |     1557.39
 Frankfurt | Mar   |        777 |     3956.98
 Prague    | Jan   |        101 |     4875.33
 Bangalore | May   |        317 |     8936.99
 Beijing   | Jul   |        411 |    11600.67
 Cleveland | Oct   |       3812 |    96645.37
(6 rows)
</code></pre>
<p>The <code>pxf_s3_textsimple_r1</code> table includes the records you individually inserted, as well as the full contents of the <code>pxf_s3_textsimple</code> table if you performed the optional step.</p>
</li>
<li>
<p>Create a second SynxDB writable external table, this time using Gzip compression and employing a colon <code>:</code> as the delimiter:</p>
<pre><code class="language-sql">postgres=# CREATE WRITABLE EXTERNAL TABLE pxf_s3_writetbl_2 (location text, month text, num_orders int, total_sales float8)
            LOCATION ('pxf://BUCKET/pxf_examples/pxfwrite_s3_textsimple2?PROFILE=s3:text&amp;SERVER=s3srvcfg&amp;COMPRESSION_CODEC=gzip')
          FORMAT 'TEXT' (delimiter=':');
</code></pre>
</li>
<li>
<p>Write a few records to the <code>pxfwrite_s3_textsimple2</code> S3 directory by inserting directly into the <code>pxf_s3_writetbl_2</code> table:</p>
<pre><code class="language-sql">gpadmin=# INSERT INTO pxf_s3_writetbl_2 VALUES ( 'Frankfurt', 'Mar', 777, 3956.98 );
gpadmin=# INSERT INTO pxf_s3_writetbl_2 VALUES ( 'Cleveland', 'Oct', 3812, 96645.37 );
</code></pre>
</li>
<li>
<p>To query data from the newly-created S3 directory named <code>pxfwrite_s3_textsimple2</code>, you can create a readable external SynxDB table as described above that references this S3 directory and specifies <code>FORMAT 'CSV' (delimiter=':')</code>.</p>
</li>
</ol>
<h2 id="about-reading-data-containing-multi-byte-or-multi-character-delimiters"><a class="header" href="#about-reading-data-containing-multi-byte-or-multi-character-delimiters"><a id="multibyte_delim"></a>About Reading Data Containing Multi-Byte or Multi-Character Delimiters</a></h2>
<p>You can use only a <code>*:csv</code> PXF profile to read data from an object store that contains a multi-byte delimiter or a delimiter with multiple characters. The syntax for creating a readable external table for such data follows:</p>
<pre><code class="language-sql">CREATE EXTERNAL TABLE &lt;table_name&gt;
    ( &lt;column_name&gt; &lt;data_type&gt; [, ...] | LIKE &lt;other_table&gt; )
LOCATION ('pxf://&lt;path-to-file&gt;?PROFILE=&lt;objstore&gt;:csv[&amp;SERVER=&lt;server_name&gt;][&amp;IGNORE_MISSING_PATH=&lt;boolean&gt;][&amp;SKIP_HEADER_COUNT=&lt;numlines&gt;][&amp;NEWLINE=&lt;bytecode&gt;]')
FORMAT 'CUSTOM' (FORMATTER='pxfdelimited_import' &lt;option&gt;[=|&lt;space&gt;][E]'&lt;value&gt;');
</code></pre>
<p>Note the <code>FORMAT</code> line in the syntax block. While the syntax is similar to that of reading CSV, PXF requires a custom formatter to read data containing a multi-byte or multi-character delimiter. You must specify the <code>'CUSTOM'</code> format and the <code>pxfdelimited_import</code> formatter. You must also specify a delimiter in the formatter options.</p>
<p>PXF recognizes the following formatter options when reading data from an object store that contains a multi-byte or multi-character delimiter:</p>
<div class="table-wrapper"><table><thead><tr><th>Option Name</th><th>Value Description</th><th>Default Value</th></tr></thead><tbody>
<tr><td>DELIMITER=&lt;delim_string&gt;</td><td>The single-byte or multi-byte delimiter string that separates columns. The string may be up to 32 bytes in length, and may not contain quote or escape characters. <strong>Required</strong></td><td>None</td></tr>
<tr><td>QUOTE=&lt;char&gt;</td><td>The single one-byte ASCII quotation character for all columns.</td><td>None</td></tr>
<tr><td>ESCAPE=&lt;char&gt;</td><td>The single one-byte ASCII character used to escape special characters (for example, the <code>DELIM</code>, <code>QUOTE</code>,  or <code>NEWLINE</code> value, or the <code>ESCAPE</code> value itself).</td><td>None, or the <code>QUOTE</code> value if that is set</td></tr>
<tr><td>NEWLINE=&lt;bytecode&gt;</td><td>The end-of-line indicator that designates the end of a row. Valid values are <code>LF</code> (line feed), <code>CR</code> (carriage return), or <code>CRLF</code> (carriage return plus line feed.</td><td><code>LF</code></td></tr>
</tbody></table>
</div>
<p>The following sections provide further information about, and examples for, specifying the delimiter, quote, escape, and new line options.</p>
<h3 id="specifying-the-delimiter"><a class="header" href="#specifying-the-delimiter"><a id="about_delim"></a>Specifying the Delimiter</a></h3>
<p>You must directly specify the delimiter or provide its byte representation. For example, given the following sample data that uses a <code>¤</code> currency symbol delimiter:</p>
<pre><code>133¤Austin¤USA
321¤Boston¤USA
987¤Paris¤France
</code></pre>
<p>To read this data from S3 using a PXF server configuration named <code>s3srvcfg</code>, create the external table as follows:</p>
<pre><code>CREATE READABLE EXTERNAL TABLE s3_mbyte_delim (id int, city text, country text)
  LOCATION ('pxf://multibyte_currency?PROFILE=s3:csv&amp;SERVER=s3srvcfg')
FORMAT 'CUSTOM' (FORMATTER='pxfdelimited_import', DELIMITER='¤'); 
</code></pre>
<h4 id="about-specifying-the-byte-representation-of-the-delimiter"><a class="header" href="#about-specifying-the-byte-representation-of-the-delimiter"><a id="delim_byterep"></a>About Specifying the Byte Representation of the Delimiter</a></h4>
<p>You can directly specify the delimiter or provide its byte representation. If you choose to specify the byte representation of the delimiter:</p>
<ul>
<li>You must specify the byte representation of the delimiter in <code>E'&lt;value&gt;'</code> format.</li>
<li>Because some characters have different byte representations in different encodings, you must specify the byte representation of the delimiter in the <em>database encoding</em>.</li>
</ul>
<p>For example, if the database encoding is <code>UTF8</code>, the file encoding is <code>LATIN1</code>, and the delimiter is the <code>¤</code> currency symbol, you must specify the <code>UTF8</code> byte representation for <code>¤</code>, which is <code>\xC2\xA4</code>:</p>
<pre><code>CREATE READABLE EXTERNAL TABLE s3_byterep_delim (id int, city text, country text)
  LOCATION ('pxf://multibyte_example?PROFILE=s3:csv&amp;SERVER=s3srvcfg')
FORMAT 'CUSTOM' (FORMATTER='pxfdelimited_import', DELIMITER=E'\xC2\xA4') ENCODING 'LATIN1';
</code></pre>
<h3 id="about-specifying-quote-and-escape-characters"><a class="header" href="#about-specifying-quote-and-escape-characters"><a id="about_qe"></a>About Specifying Quote and Escape Characters</a></h3>
<p>When PXF reads data that contains a multi-byte or multi-character delimiter, its behavior depends on the quote and escape character settings:</p>
<div class="table-wrapper"><table><thead><tr><th>QUOTE Set?</th><th>ESCAPE Set?</th><th>PXF Behaviour</th></tr></thead><tbody>
<tr><td>No<sup>1</sup></td><td>No</td><td>PXF reads the data as-is.</td></tr>
<tr><td>Yes<sup>2</sup></td><td>Yes</td><td>PXF reads the data between quote characters as-is and un-escapes only the quote and escape characters.</td></tr>
<tr><td>Yes<sup>2</sup></td><td>No (<code>ESCAPE 'OFF'</code>)</td><td>PXF reads the data between quote characters as-is.</td></tr>
<tr><td>No<sup>1</sup></td><td>Yes</td><td>PXF reads the data as-is and un-escapes only the delimiter, newline, and escape itself.</td></tr>
</tbody></table>
</div>
<p><sup>1</sup> All data columns must be un-quoted when you do not specify a quote character.</p>
<p><sup>2</sup> All data columns must quoted when you specify a quote character.</p>
<blockquote>
<p><strong>Note</strong> PXF expects that there are no extraneous characters between the quote value and the delimiter value, nor between the quote value and the end-of-line value. Additionally, there must be no white space between delimiters and quotes.</p>
</blockquote>
<h3 id="about-the-newline-options"><a class="header" href="#about-the-newline-options"><a id="about_newline"></a>About the NEWLINE Options</a></h3>
<p>PXF requires that every line in the file be terminated with the same new line value.</p>
<p>By default, PXF uses the line feed character (<code>LF</code>) for the new line delimiter. When the new line delimiter for the external file is also a line feed, you need not specify the <code>NEWLINE</code> formatter option.</p>
<p>If the <code>NEWLINE</code> formatter option is provided and contains <code>CR</code> or <code>CRLF</code>, you must also specify the same <code>NEWLINE</code> option in the external table <code>LOCATION</code> URI. For example, if the new line delimiter is <code>CRLF</code>, create the external table as follows:</p>
<pre><code>CREATE READABLE EXTERNAL TABLE s3_mbyte_newline_crlf (id int, city text, country text)
  LOCATION ('pxf://multibyte_example_crlf?PROFILE=s3:csv&amp;SERVER=s3srvcfg&amp;NEWLINE=CRLF')
FORMAT 'CUSTOM' (FORMATTER='pxfdelimited_import', DELIMITER='¤', NEWLINE='CRLF');
</code></pre>
<h3 id="examples"><a class="header" href="#examples"><a id="mbd_examples"></a>Examples</a></h3>
<h4 id="delimiter-with-quoted-data"><a class="header" href="#delimiter-with-quoted-data"><a id="qe_example"></a>Delimiter with Quoted Data</a></h4>
<p>Given the following sample data that uses the double-quote (<code>"</code>) quote character and the delimiter <code>¤</code>:</p>
<pre><code>"133"¤"Austin"¤"USA"
"321"¤"Boston"¤"USA"
"987"¤"Paris"¤"France"
</code></pre>
<p>Create the external table as follows:</p>
<pre><code>CREATE READABLE EXTERNAL TABLE s3_mbyte_delim_quoted (id int, city text, country text)
  LOCATION ('pxf://multibyte_q?PROFILE=s3:csv&amp;SERVER=s3srvcfg')
FORMAT 'CUSTOM' (FORMATTER='pxfdelimited_import', DELIMITER='¤', QUOTE '"'); 
</code></pre>
<h4 id="delimiter-with-quoted-and-escaped-data"><a class="header" href="#delimiter-with-quoted-and-escaped-data"><a id="qe_example"></a>Delimiter with Quoted and Escaped Data</a></h4>
<p>Given the following sample data that uses the quote character <code>"</code>, the escape character <code>\</code>, and the delimiter <code>¤</code>:</p>
<pre><code>"\"hello, my name is jane\" she said. let's escape something \\"¤"123"
</code></pre>
<p>Create the external table as follows:</p>
<pre><code>CREATE READABLE EXTERNAL TABLE s3_mybte_delim_quoted_escaped (sentence text, num int)
  LOCATION ('pxf://multibyte_qe?PROFILE=s3:csv&amp;SERVER=s3srvcfg')
FORMAT 'CUSTOM' (FORMATTER='pxfdelimited_import', DELIMITER='¤', QUOTE '"', ESCAPE '\');
</code></pre>
<p>With this external table definition, PXF reads the <code>sentence</code> text field as:</p>
<pre><code>SELECT sentence FROM s3_mbyte_delim_quoted_escaped;

                          sentence 
-------------------------------------------------------------
 "hello, my name is jane" she said. let's escape something \
(1 row)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../pxf/access_s3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../pxf/objstore_fixedwidth.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../pxf/access_s3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../pxf/objstore_fixedwidth.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
