<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Writing a Foreign Data Wrapper - SynxDB 2 Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SynxDB 2 Documentation</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                        &nbsp;&nbsp;&nbsp;&nbsp;
                        <a href="https://www.synxdata.com/"><img id="fa fa-print" src="../../SYNX-Text-and-Circular-Logo-142x28-White-text-Black-background.png" alt="Synx Data Labs Logo"/></a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="writing-a-foreign-data-wrapper"><a class="header" href="#writing-a-foreign-data-wrapper">Writing a Foreign Data Wrapper</a></h1>
<p>This chapter outlines how to write a new foreign-data wrapper.</p>
<p>All operations on a foreign table are handled through its foreign-data wrapper (FDW), a library that consists of a set of functions that the core SynxDB server calls. The foreign-data wrapper is responsible for fetching data from the remote data store and returning it to the SynxDB executor. If updating foreign-data is supported, the wrapper must handle that, too.</p>
<p>The foreign-data wrappers included in the SynxDB open source github repository are good references when trying to write your own. You may want to examine the source code for the file_fdw and postgres_fdw modules in the <code>contrib/</code> directory. The <a href="../../ref_guide/sql_commands/CREATE_FOREIGN_DATA_WRAPPER.html">CREATE FOREIGN DATA WRAPPER</a> reference page also provides some useful details.</p>
<blockquote>
<p><strong>Note</strong> The SQL standard specifies an interface for writing foreign-data wrappers. SynxDB does not implement that API, however, because the effort to accommodate it into SynxDB would be large, and the standard API hasnâ€™t yet gained wide adoption.</p>
</blockquote>
<p>This topic includes the following sections:</p>
<ul>
<li><a href="#reqs">Requirements</a></li>
<li><a href="#limits">Known Issues and Limitations</a></li>
<li><a href="#includes">Header Files</a></li>
<li><a href="#topic2">Foreign Data Wrapper Functions</a></li>
<li><a href="#topic3">Foreign Data Wrapper Callback Functions</a></li>
<li><a href="#helper">Foreign Data Wrapper Helper Functions</a></li>
<li><a href="#topic5">SynxDB Considerations</a></li>
<li><a href="#pkg">Building a Foreign Data Wrapper Extension with PGXS</a></li>
<li><a href="#deployconsider">Deployment Considerations</a></li>
</ul>
<h2 id="requirements"><a class="header" href="#requirements"><a id="reqs"></a>Requirements</a></h2>
<p>When you develop with the SynxDB foreign-data wrapper API:</p>
<ul>
<li>You must develop your code on a system with the same hardware and software architecture as that of your SynxDB hosts.</li>
<li>Your code must be written in a compiled language such as C, using the version-1 interface. For details on C language calling conventions and dynamic loading, refer to <a href="https://www.postgresql.org/docs/9.4/xfunc-c.html">C Language Functions</a> in the PostgreSQL documentation.</li>
<li>Symbol names in your object files must not conflict with each other nor with symbols defined in the SynxDB server. You must rename your functions or variables if you get error messages to this effect.</li>
<li>Review the foreign table introduction described in <a href="g-foreign.html">Accessing External Data with Foreign Tables</a>.</li>
</ul>
<h2 id="known-issues-and-limitations"><a class="header" href="#known-issues-and-limitations"><a id="limits"></a>Known Issues and Limitations</a></h2>
<p>The SynxDB 2 foreign-data wrapper implementation has the following known issues and limitations:</p>
<ul>
<li>SynxDB supports all values of the <code>mpp_execute</code> option value for foreign table scans only. SynxDB supports parallel write operations only when <code>mpp_execute</code> is set to <code>'all segments'</code>; SynxDB initiates write operations through the master for all other <code>mpp_execute</code> settings. See <a href="#topic5">SynxDB Considerations</a>.</li>
</ul>
<h2 id="header-files"><a class="header" href="#header-files"><a id="includes"></a>Header Files</a></h2>
<p>The SynxDB header files that you may use when you develop a foreign-data wrapper are located in the <code>greenplum-db/src/include/</code> directory (when developing against the SynxDB open source github repository), or installed in the <code>$GPHOME/include/postgresql/server/</code> directory (when developing against a SynxDB installation):</p>
<ul>
<li>foreign/fdwapi.h - FDW API structures and callback function signatures</li>
<li>foreign/foreign.h - foreign-data wrapper helper structs and functions</li>
<li>catalog/pg_foreign_table.h - foreign table definition</li>
<li>catalog/pg_foreign_server.h - foreign server definition</li>
</ul>
<p>Your FDW code may also be dependent on header files and libraries required to access the remote data store.</p>
<h2 id="foreign-data-wrapper-functions"><a class="header" href="#foreign-data-wrapper-functions"><a id="topic2"></a>Foreign Data Wrapper Functions</a></h2>
<p>The developer of a foreign-data wrapper must implement an SQL-invokable <em>handler</em> function, and optionally an SQL-invokable <em>validator</em> function. Both functions must be written in a compiled language such as C, using the version-1 interface.</p>
<p>The <em>handler</em> function simply returns a struct of function pointers to callback functions that will be called by the SynxDB planner, executor, and various maintenance commands. The <em>handler</em> function must be registered with SynxDB as taking no arguments and returning the special pseudo-type <code>fdw_handler</code>. For example:</p>
<pre><code>CREATE FUNCTION NEW_fdw_handler()
  RETURNS fdw_handler
  AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</code></pre>
<p>Most of the effort in writing a foreign-data wrapper is in implementing the callback functions. The FDW API callback functions, plain C functions that are not visible or callable at the SQL level, are described in <a href="#topic3">Foreign Data Wrapper Callback Functions</a>.</p>
<p>The <em>validator</em> function is responsible for validating options provided in <code>CREATE</code> and <code>ALTER</code> commands for its foreign-data wrapper, as well as foreign servers, user mappings, and foreign tables using the wrapper. The <em>validator</em> function must be registered as taking two arguments, a text array containing the options to be validated, and an OID representing the type of object with which the options are associated. For example:</p>
<pre><code>CREATE FUNCTION NEW_fdw_validator( text[], oid )
  RETURNS void
  AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</code></pre>
<p>The OID argument reflects the type of the system catalog that the object would be stored in, one of <code>ForeignDataWrapperRelationId</code>, <code>ForeignServerRelationId</code>, <code>UserMappingRelationId</code>, or <code>ForeignTableRelationId</code>. If no <em>validator</em> function is supplied by a foreign data wrapper, SynxDB does not check option validity at object creation time or object alteration time.</p>
<h2 id="foreign-data-wrapper-callback-functions"><a class="header" href="#foreign-data-wrapper-callback-functions"><a id="topic3"></a>Foreign Data Wrapper Callback Functions</a></h2>
<p>The foreign-data wrapper API defines callback functions that SynxDB invokes when scanning and updating foreign tables. The API also includes callbacks for performing explain and analyze operations on a foreign table.</p>
<p>The <em>handler</em> function of a foreign-data wrapper returns a <code>palloc</code>â€™d <code>FdwRoutine</code> struct containing pointers to callback functions described below. The <code>FdwRoutine</code> struct is located in the <code>foreign/fdwapi.h</code> header file, and is defined as follows:</p>
<pre><code>/*
 * FdwRoutine is the struct returned by a foreign-data wrapper's handler
 * function.  It provides pointers to the callback functions needed by the
 * planner and executor.
 *
 * More function pointers are likely to be added in the future.  Therefore
 * it's recommended that the handler initialize the struct with
 * makeNode(FdwRoutine) so that all fields are set to NULL.  This will
 * ensure that no fields are accidentally left undefined.
 */
typedef struct FdwRoutine
{
	NodeTag		type;

	/* Functions for scanning foreign tables */
	GetForeignRelSize_function GetForeignRelSize;
	GetForeignPaths_function GetForeignPaths;
	GetForeignPlan_function GetForeignPlan;
	BeginForeignScan_function BeginForeignScan;
	IterateForeignScan_function IterateForeignScan;
	ReScanForeignScan_function ReScanForeignScan;
	EndForeignScan_function EndForeignScan;

	/*
	 * Remaining functions are optional.  Set the pointer to NULL for any that
	 * are not provided.
	 */

	/* Functions for updating foreign tables */
	AddForeignUpdateTargets_function AddForeignUpdateTargets;
	PlanForeignModify_function PlanForeignModify;
	BeginForeignModify_function BeginForeignModify;
	ExecForeignInsert_function ExecForeignInsert;
	ExecForeignUpdate_function ExecForeignUpdate;
	ExecForeignDelete_function ExecForeignDelete;
	EndForeignModify_function EndForeignModify;
	IsForeignRelUpdatable_function IsForeignRelUpdatable;

	/* Support functions for EXPLAIN */
	ExplainForeignScan_function ExplainForeignScan;
	ExplainForeignModify_function ExplainForeignModify;

	/* Support functions for ANALYZE */
	AnalyzeForeignTable_function AnalyzeForeignTable;
} FdwRoutine;

</code></pre>
<p>You must implement the scan-related functions in your foreign-data wrapper; implementing the other callback functions is optional.</p>
<p>Scan-related callback functions include:</p>
<table class="table" id="topic3__in201681"><caption></caption><colgroup><col style="width:35.573122529644266%"><col style="width:64.42687747035573%"></colgroup><thead class="thead">
            <tr class="row">
              <th class="entry" id="topic3__in201681__entry__1">Callback Signature</th>
              <th class="entry" id="topic3__in201681__entry__2">Description</th>
            </tr>
          </thead><tbody class="tbody">
            <tr class="row">
              <td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
GetForeignRelSize (PlannerInfo *root,
                   RelOptInfo *baserel,
                   Oid foreigntableid)</code></pre></td>
              <td class="entry" headers="topic3__in201681__entry__2">Obtain relation size estimates for a foreign table.
                Called at the beginning of planning for a query on a foreign table.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
GetForeignPaths (PlannerInfo *root,
                 RelOptInfo *baserel,
                 Oid foreigntableid)</code></pre></td>
              <td class="entry" headers="topic3__in201681__entry__2">Create possible access paths for a scan on a
                foreign table. Called during query planning. <div class="note note note_note"><span class="note__title">Note:</span> A SynxDB
                Database-compatible FDW must call
                <code class="ph codeph">create_foreignscan_path()</code> in its
                <code class="ph codeph">GetForeignPaths()</code> callback function.</div></td>
            </tr>
            <tr class="row">
              <td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>ForeignScan *
GetForeignPlan (PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid,
                ForeignPath *best_path,
                List *tlist,
                List *scan_clauses)</code></pre></td>
              <td class="entry" headers="topic3__in201681__entry__2">Create a <code class="ph codeph">ForeignScan</code> plan node from
                the selected foreign access path. Called at the end of query planning.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
BeginForeignScan (ForeignScanState *node,
                  int eflags)</code></pre></td>
              <td class="entry" headers="topic3__in201681__entry__2">Begin running a foreign scan. Called during
               executor startup.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>TupleTableSlot *
IterateForeignScan (ForeignScanState *node)</code></pre></td>
              <td class="entry" headers="topic3__in201681__entry__2">Fetch one row from the foreign source, returning it
                in a tuple table slot; return NULL if no more rows are available.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
ReScanForeignScan (ForeignScanState *node)</code></pre></td>
              <td class="entry" headers="topic3__in201681__entry__2">Restart the scan from the beginning.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
EndForeignScan (ForeignScanState *node)</code></pre></td>
              <td class="entry" headers="topic3__in201681__entry__2">End the scan and release resources.</td>
            </tr>
          </tbody></table>
<p>If a foreign data wrapper supports writable foreign tables, it should provide the update-related callback functions that are required by the capabilities of the FDW. Update-related callback functions include:</p>
<table class="table" id="topic3__in201681"><caption></caption><colgroup><col style="width:35.573122529644266%"><col style="width:64.42687747035573%"></colgroup><thead class="thead">
            <tr class="row">
              <th class="entry" id="topic3__in201681__entry__1">Callback Signature</th>
              <th class="entry" id="topic3__in201681__entry__2">Description</th>
            </tr>
          </thead><tbody class="tbody">
            <tr class="row">
              <td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
AddForeignUpdateTargets (Query *parsetree,
                         RangeTblEntry *target_rte,
                         Relation target_relation)</code></pre></td>
              <td class="entry" headers="topic3__in201681__entry__2">Add additional information in the foreign
                table that will be retrieved during an update or delete operation 
                to identify the exact row on which to operate.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>List *
PlanForeignModify (PlannerInfo *root,
                   ModifyTable *plan,
                   Index resultRelation,
                   int subplan_index)</code></pre></td>
              <td class="entry" headers="topic3__in201681__entry__2">Perform additional planning actions required
                for an insert, update, or delete operation on a foreign table,
                and return the information generated.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
BeginForeignModify (ModifyTableState *mtstate,
                    ResultRelInfo *rinfo,
                    List *fdw_private,
                    int subplan_index,
                    int eflags)</code></pre></td>
              <td class="entry" headers="topic3__in201681__entry__2">Begin executing a modify operation on a
                foreign table. Called during executor startup.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>TupleTableSlot *
ExecForeignInsert (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot)</code></pre></td>
              <td class="entry" headers="topic3__in201681__entry__2">Insert a single tuple into the foreign table.
                Return a slot containing the data that was actually inserted, or
                NULL if no row was inserted.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>TupleTableSlot *
ExecForeignUpdate (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot)</code></pre></td>
              <td class="entry" headers="topic3__in201681__entry__2">Update a single tuple in the foreign table.
                Return a slot containing the row as it was actually updated, or
                NULL if no row was updated. </td>
            </tr>
            <tr class="row">
              <td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>TupleTableSlot *
ExecForeignDelete (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot)</code></pre></td>
              <td class="entry" headers="topic3__in201681__entry__2">Delete a single tuple from the foreign table.
                Return a slot containing the row that was deleted, or NULL if no
                row was deleted.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
EndForeignModify (EState *estate,
                  ResultRelInfo *rinfo)</code></pre></td>
              <td class="entry" headers="topic3__in201681__entry__2">End the update and release resources.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>int
IsForeignRelUpdatable (Relation rel)</code></pre></td>
              <td class="entry" headers="topic3__in201681__entry__2">Report the update operations supported by the
                specified foreign table.</td>
            </tr>
          </tbody></table>
<p>Refer to <a href="https://www.postgresql.org/docs/9.4/fdw-callbacks.html">Foreign Data Wrapper Callback Routines</a> in the PostgreSQL documentation for detailed information about the inputs and outputs of the FDW callback functions.</p>
<h2 id="foreign-data-wrapper-helper-functions"><a class="header" href="#foreign-data-wrapper-helper-functions"><a id="helper"></a>Foreign Data Wrapper Helper Functions</a></h2>
<p>The FDW API exports several helper functions from the SynxDB core server so that authors of foreign-data wrappers have easy access to attributes of FDW-related objects, such as options provided when the user creates or alters the foreign-data wrapper, server, or foreign table. To use these helper functions, you must include <code>foreign.h</code> header file in your source file:</p>
<pre><code>#include "foreign/foreign.h"
</code></pre>
<p>The FDW API includes the helper functions listed in the table below. Refer to <a href="https://www.postgresql.org/docs/9.4/fdw-helpers.html">Foreign Data Wrapper Helper Functions</a> in the PostgreSQL documentation for more information about these functions.</p>
<table class="table" id="helper__fdw_helper"><caption></caption><colgroup><col style="width:35.573122529644266%"><col style="width:64.42687747035573%"></colgroup><thead class="thead">
            <tr class="row">
              <th class="entry" id="helper__fdw_helper__entry__1">Helper Signature</th>
              <th class="entry" id="helper__fdw_helper__entry__2">Description</th>
            </tr>
          </thead><tbody class="tbody">
            <tr class="row">
              <td class="entry" headers="helper__fdw_helper__entry__1"><pre class="pre codeblock"><code>ForeignDataWrapper *
GetForeignDataWrapper(Oid fdwid);</code></pre></td>
              <td class="entry" headers="helper__fdw_helper__entry__2">Returns the <code class="ph codeph">ForeignDataWrapper</code>
                object for the foreign-data wrapper with the given OID.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="helper__fdw_helper__entry__1"><pre class="pre codeblock"><code>ForeignDataWrapper *
GetForeignDataWrapperByName(const char *name, bool missing_ok);</code></pre></td>
              <td class="entry" headers="helper__fdw_helper__entry__2">Returns the <code class="ph codeph">ForeignDataWrapper</code>
                object for the foreign-data wrapper with the given name.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="helper__fdw_helper__entry__1"><pre class="pre codeblock"><code>ForeignServer *
GetForeignServer(Oid serverid);</code></pre></td>
              <td class="entry" headers="helper__fdw_helper__entry__2">Returns the <code class="ph codeph">ForeignServer</code>
                object for the foreign server with the given OID.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="helper__fdw_helper__entry__1"><pre class="pre codeblock"><code>ForeignServer *
GetForeignServerByName(const char *name, bool missing_ok);</code></pre></td>
              <td class="entry" headers="helper__fdw_helper__entry__2">Returns the <code class="ph codeph">ForeignServer</code>
                object for the foreign server with the given name.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="helper__fdw_helper__entry__1"><pre class="pre codeblock"><code>UserMapping *
GetUserMapping(Oid userid, Oid serverid);</code></pre></td>
              <td class="entry" headers="helper__fdw_helper__entry__2">Returns the <code class="ph codeph">UserMapping</code>
                object for the user mapping of the given role on the given
                server.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="helper__fdw_helper__entry__1"><pre class="pre codeblock"><code>ForeignTable *
GetForeignTable(Oid relid);</code></pre></td>
              <td class="entry" headers="helper__fdw_helper__entry__2">Returns the <code class="ph codeph">ForeignTable</code>
                object for the foreign table with the given OID.</td>
            </tr>
            <tr class="row">
              <td class="entry" headers="helper__fdw_helper__entry__1"><pre class="pre codeblock"><code>List *
GetForeignColumnOptions(Oid relid, AttrNumber attnum);</code></pre></td>
              <td class="entry" headers="helper__fdw_helper__entry__2">Returns the per-column FDW options for the
                column with the given foreign table OID and attribute number.</td>
            </tr>
          </tbody></table>
<h2 id="synxdb-considerations"><a class="header" href="#synxdb-considerations"><a id="topic5"></a>SynxDB Considerations</a></h2>
<p>A SynxDB user can specify the <code>mpp_execute</code> option when they create or alter a foreign table, foreign server, or foreign data wrapper. A SynxDB-compatible foreign-data wrapper examines the <code>mpp_execute</code> option value and uses it to determine where to request or send data - from the <code>master</code> (the default), <code>any</code> (master or any one segment), or <code>all segments</code> (parallel read/write).</p>
<p>SynxDB supports all <code>mpp_execute</code> settings for a scan.</p>
<p>SynxDB supports parallel write when <code>mpp_execute 'all segments"</code> is set. For all other <code>mpp_execute</code> settings, SynxDB executes write/update operations initiated by a foreign data wrapper on the SynxDB master node.</p>
<blockquote>
<p><strong>Note</strong> When <code>mpp_execute 'all segments'</code> is set, SynxDB creates the foreign table with a random partition policy. This enables a foreign data wrapper to write to a foreign table from all segments.</p>
</blockquote>
<p>The following scan code snippet probes the <code>mpp_execute</code> value associated with a foreign table:</p>
<pre><code>ForeignTable *table = GetForeignTable(foreigntableid);
if (table-&gt;exec_location == FTEXECLOCATION_ALL_SEGMENTS)
{
    ...
}
else if (table-&gt;exec_location == FTEXECLOCATION_ANY)
{
    ...
}
else if (table-&gt;exec_location == FTEXECLOCATION_MASTER)
{
    ...
} 
</code></pre>
<p>If the foreign table was not created with an <code>mpp_execute</code> option setting, the <code>mpp_execute</code> setting of the foreign server, and then the foreign data wrapper, is probed and used. If none of the foreign-data-related objects has an <code>mpp_execute</code> setting, the default setting is <code>master</code>.</p>
<p>If a foreign-data wrapper supports <code>mpp_execute 'all'</code>, it will implement a policy that matches SynxDB segments to data. So as not to duplicate data retrieved from the remote, the FDW on each segment must be able to establish which portion of the data is their responsibility. An FDW may use the segment identifier and the number of segments to help make this determination. The following code snippet demonstrates how a foreign-data wrapper may retrieve the segment number and total number of segments:</p>
<pre><code>int segmentNumber = GpIdentity.segindex;
int totalNumberOfSegments = getgpsegmentCount();
</code></pre>
<h2 id="building-a-foreign-data-wrapper-extension-with-pgxs"><a class="header" href="#building-a-foreign-data-wrapper-extension-with-pgxs"><a id="pkg"></a>Building a Foreign Data Wrapper Extension with PGXS</a></h2>
<p>You compile the foreign-data wrapper functions that you write with the FDW API into one or more shared libraries that the SynxDB server loads on demand.</p>
<p>You can use the PostgreSQL build extension infrastructure (PGXS) to build the source code for your foreign-data wrapper against a SynxDB installation. This framework automates common build rules for simple modules. If you have a more complicated use case, you will need to write your own build system.</p>
<p>To use the PGXS infrastructure to generate a shared library for your FDW, create a simple <code>Makefile</code> that sets PGXS-specific variables.</p>
<blockquote>
<p><strong>Note</strong> Refer to <a href="https://www.postgresql.org/docs/9.4/extend-pgxs.html">Extension Building Infrastructure</a> in the PostgreSQL documentation for information about the <code>Makefile</code> variables supported by PGXS.</p>
</blockquote>
<p>For example, the following <code>Makefile</code> generates a shared library in the current working directory named <code>base_fdw.so</code> from two C source files, base_fdw_1.c and base_fdw_2.c:</p>
<pre><code>MODULE_big = base_fdw
OBJS = base_fdw_1.o base_fdw_2.o

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)

PG_CPPFLAGS = -I$(shell $(PG_CONFIG) --includedir)
SHLIB_LINK = -L$(shell $(PG_CONFIG) --libdir)
include $(PGXS)

</code></pre>
<p>A description of the directives used in this <code>Makefile</code> follows:</p>
<ul>
<li><code>MODULE_big</code> - identifes the base name of the shared library generated by the <code>Makefile</code></li>
<li><code>PG_CPPFLAGS</code> - adds the SynxDB installation <code>include/</code> directory to the compiler header file search path</li>
<li><code>SHLIB_LINK</code> adds the SynxDB installation library directory (<code>$GPHOME/lib/</code>) to the linker search path</li>
<li>The <code>PG_CONFIG</code> and <code>PGXS</code> variable settings and the <code>include</code> statement are required and typically reside in the last three lines of the <code>Makefile</code>.</li>
</ul>
<p>To package the foreign-data wrapper as a SynxDB extension, you create script (<code>newfdw--version.sql</code>) and control (<code>newfdw.control</code>) files that register the FDW <em>handler</em> and <em>validator</em> functions, create the foreign data wrapper, and identify the characteristics of the FDW shared library file.</p>
<blockquote>
<p><strong>Note</strong> <a href="https://www.postgresql.org/docs/9.4/extend-extensions.html">Packaging Related Objects into an Extension</a> in the PostgreSQL documentation describes how to package an extension.</p>
</blockquote>
<p>Example foreign-data wrapper extension script file named <code>base_fdw--1.0.sql</code>:</p>
<pre><code>CREATE FUNCTION base_fdw_handler()
  RETURNS fdw_handler
  AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;

CREATE FUNCTION base_fdw_validator(text[], oid)
  RETURNS void
  AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;

CREATE FOREIGN DATA WRAPPER base_fdw
  HANDLER base_fdw_handler
  VALIDATOR base_fdw_validator;
</code></pre>
<p>Example FDW control file named <code>base_fdw.control</code>:</p>
<pre><code># base_fdw FDW extension
comment = 'base foreign-data wrapper implementation; does not do much'
default_version = '1.0'
module_pathname = '$libdir/base_fdw'
relocatable = true
</code></pre>
<p>When you add the following directives to the <code>Makefile</code>, you identify the FDW extension control file base name (<code>EXTENSION</code>) and SQL script (<code>DATA</code>):</p>
<pre><code>EXTENSION = base_fdw
DATA = base_fdw--1.0.sql
</code></pre>
<p>Running <code>make install</code> with these directives in the <code>Makefile</code> copies the shared library and FDW SQL and control files into the specified or default locations in your SynxDB installation (<code>$GPHOME</code>).</p>
<h2 id="deployment-considerations"><a class="header" href="#deployment-considerations"><a id="deployconsider"></a>Deployment Considerations</a></h2>
<p>You must package the FDW shared library and extension files in a form suitable for deployment in a SynxDB cluster. When you construct and deploy the package, take into consideration the following:</p>
<ul>
<li>The FDW shared library must be installed to the same file system location on the master host and on every segment host in the SynxDB cluster. You specify this location in the <code>.control</code> file. This location is typically the <code>$GPHOME/lib/postgresql/</code> directory.</li>
<li>The FDW <code>.sql</code> and <code>.control</code> files must be installed to the <code>$GPHOME/share/postgresql/extension/</code> directory on the master host and on every segment host in the SynxDB cluster.</li>
<li>The <code>gpadmin</code> user must have permission to traverse the complete file system path to the FDW shared library file and extension files.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../admin_guide/external/g-foreign.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../admin_guide/external/g-using-the-synxdb-parallel-file-server-gpfdist.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../admin_guide/external/g-foreign.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../admin_guide/external/g-using-the-synxdb-parallel-file-server-gpfdist.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
