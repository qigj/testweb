<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CREATE FUNCTION - SynxDB 2 Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SynxDB 2 Documentation</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                        &nbsp;&nbsp;&nbsp;&nbsp;
                        <a href="https://www.synxdata.com/"><img id="fa fa-print" src="../../SYNX-Text-and-Circular-Logo-142x28-White-text-Black-background.png" alt="Synx Data Labs Logo"/></a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="create-function"><a class="header" href="#create-function">CREATE FUNCTION</a></h1>
<p>Defines a new function.</p>
<h2 id="synopsis"><a class="header" href="#synopsis"><a id="section2"></a>Synopsis</a></h2>
<pre><code class="language-{#sql_command_synopsis}">CREATE [OR REPLACE] FUNCTION &lt;name&gt;    
    ( [ [&lt;argmode&gt;] [&lt;argname&gt;] &lt;argtype&gt; [ { DEFAULT | = } &lt;default_expr&gt; ] [, ...] ] )
      [ RETURNS &lt;rettype&gt; 
        | RETURNS TABLE ( &lt;column_name&gt; &lt;column_type&gt; [, ...] ) ]
    { LANGUAGE &lt;langname&gt;
    | WINDOW
    | IMMUTABLE | STABLE | VOLATILE | [NOT] LEAKPROOF
    | CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
    | NO SQL | CONTAINS SQL | READS SQL DATA | MODIFIES SQL
    | [EXTERNAL] SECURITY INVOKER | [EXTERNAL] SECURITY DEFINER
    | EXECUTE ON { ANY | MASTER | ALL SEGMENTS | INITPLAN }
    | COST &lt;execution_cost&gt;
    | SET &lt;configuration_parameter&gt; { TO &lt;value&gt; | = &lt;value&gt; | FROM CURRENT }
    | AS '&lt;definition&gt;'
    | AS '&lt;obj_file&gt;', '&lt;link_symbol&gt;' } ...
    [ WITH ({ DESCRIBE = describe_function
           } [, ...] ) ]
</code></pre>
<h2 id="description"><a class="header" href="#description"><a id="section3"></a>Description</a></h2>
<p><code>CREATE FUNCTION</code> defines a new function. <code>CREATE OR REPLACE FUNCTION</code> either creates a new function, or replaces an existing definition.</p>
<p>The name of the new function must not match any existing function with the same input argument types in the same schema. However, functions of different argument types may share a name (overloading).</p>
<p>To update the definition of an existing function, use <code>CREATE OR REPLACE FUNCTION</code>. It is not possible to change the name or argument types of a function this way (this would actually create a new, distinct function). Also, <code>CREATE OR REPLACE FUNCTION</code> will not let you change the return type of an existing function. To do that, you must drop and recreate the function. When using <code>OUT</code> parameters, that means you cannot change the types of any <code>OUT</code> parameters except by dropping the function. If you drop and then recreate a function, you will have to drop existing objects (rules, views, triggers, and so on) that refer to the old function. Use <code>CREATE OR REPLACE FUNCTION</code> to change a function definition without breaking objects that refer to the function.</p>
<p>The user that creates the function becomes the owner of the function.</p>
<p>To be able to create a function, you must have <code>USAGE</code> privilege on the argument types and the return type.</p>
<p>For more information about creating functions, see the <a href="https://www.postgresql.org/docs/9.4/xfunc.html">User Defined Functions</a> section of the PostgreSQL documentation.</p>
<p><strong>Limited Use of VOLATILE and STABLE Functions</strong></p>
<p>To prevent data from becoming out-of-sync across the segments in SynxDB, any function classified as <code>STABLE</code> or <code>VOLATILE</code> cannot be run at the segment level if it contains SQL or modifies the database in any way. For example, functions such as <code>random()</code> or <code>timeofday()</code> are not allowed to run on distributed data in SynxDB because they could potentially cause inconsistent data between the segment instances.</p>
<p>To ensure data consistency, <code>VOLATILE</code> and <code>STABLE</code> functions can safely be used in statements that are evaluated on and run from the master. For example, the following statements are always run on the master (statements without a <code>FROM</code> clause):</p>
<pre><code>SELECT setval('myseq', 201);
SELECT foo();
</code></pre>
<p>In cases where a statement has a <code>FROM</code> clause containing a distributed table and the function used in the <code>FROM</code> clause simply returns a set of rows, execution may be allowed on the segments:</p>
<pre><code>SELECT * FROM foo();
</code></pre>
<p>One exception to this rule are functions that return a table reference (<code>rangeFuncs</code>) or functions that use the <code>refCursor</code> data type. Note that you cannot return a <code>refcursor</code> from any kind of function in SynxDB.</p>
<p><strong>Function Volatility and EXECUTE ON Attributes</strong></p>
<p>Volatility attributes (<code>IMMUTABLE</code>, <code>STABLE</code>, <code>VOLATILE</code>) and <code>EXECUTE ON</code> attributes specify two different aspects of function execution. In general, volatility indicates when the function is run, and <code>EXECUTE ON</code> indicates where it is run.</p>
<p>For example, a function defined with the <code>IMMUTABLE</code> attribute can be run at query planning time, while a function with the <code>VOLATILE</code> attribute must be run for every row in the query. A function with the <code>EXECUTE ON MASTER</code> attribute is run only on the master segment and a function with the <code>EXECUTE ON ALL SEGMENTS</code> attribute is run on all primary segment instances (not the master).</p>
<p>See <a href="../../admin_guide/query/topics/functions-operators.html">Using Functions and Operators</a>.</p>
<p><strong>Functions And Replicated Tables</strong></p>
<p>A user-defined function that runs only <code>SELECT</code> commands on replicated tables can run on segments. Replicated tables, created with the <code>DISTRIBUTED REPLICATED</code> clause, store all of their rows on every segment. It is safe for a function to read them on the segments, but updates to replicated tables must run on the master instance.</p>
<h2 id="parameters"><a class="header" href="#parameters"><a id="section5"></a>Parameters</a></h2>
<h3 id="name"><a class="header" href="#name">name</a></h3>
<p>The name (optionally schema-qualified) of the function to create.</p>
<h3 id="argmode"><a class="header" href="#argmode">argmode</a></h3>
<p>The mode of an argument: either <code>IN</code>, <code>OUT</code>, <code>INOUT</code>, or <code>VARIADIC</code>. If omitted, the default is <code>IN</code>. Only <code>OUT</code> arguments can follow an argument declared as <code>VARIADIC</code>. Also, <code>OUT</code> and <code>INOUT</code> arguments cannot be used together with the <code>RETURNS TABLE</code> notation.</p>
<h3 id="argname"><a class="header" href="#argname">argname</a></h3>
<p>The name of an argument. Some languages (currently only SQL and PL/pgSQL) let you use the name in the function body. For other languages the name of an input argument is just extra documentation, so far as the function itself is concerned; but you can use input argument names when calling a function to improve readability. In any case, the name of an output argument is significant, since it defines the column name in the result row type. (If you omit the name for an output argument, the system will choose a default column name.)</p>
<h3 id="argtype"><a class="header" href="#argtype">argtype</a></h3>
<p>The data type(s) of the function’s arguments (optionally schema-qualified), if any. The argument types may be base, composite, or domain types, or may reference the type of a table column.</p>
<p>Depending on the implementation language it may also be allowed to specify pseudotypes such as <code>cstring</code>. Pseudotypes indicate that the actual argument type is either incompletely specified, or outside the set of ordinary SQL data types.</p>
<p>The type of a column is referenced by writing <code>tablename.columnname%TYPE</code>. Using this feature can sometimes help make a function independent of changes to the definition of a table.</p>
<h3 id="default_expr"><a class="header" href="#default_expr">default_expr</a></h3>
<p>An expression to be used as the default value if the parameter is not specified. The expression must be coercible to the argument type of the parameter. Only <code>IN</code> and <code>INOUT</code> parameters can have a default value. Each input parameter in the argument list that follows a parameter with a default value must have a default value as well.</p>
<h3 id="rettype"><a class="header" href="#rettype">rettype</a></h3>
<p>The return data type (optionally schema-qualified). The return type can be a base, composite, or domain type, or may reference the type of a table column. Depending on the implementation language it may also be allowed to specify pseudotypes such as <code>cstring</code>. If the function is not supposed to return a value, specify <code>void</code> as the return type.</p>
<p>When there are <code>OUT</code> or <code>INOUT</code> parameters, the <code>RETURNS</code> clause may be omitted. If present, it must agree with the result type implied by the output parameters: <code>RECORD</code> if there are multiple output parameters, or the same type as the single output parameter.</p>
<p>The <code>SETOF</code> modifier indicates that the function will return a set of items, rather than a single item.</p>
<p>The type of a column is referenced by writing <code>tablename.columnname%TYPE</code>.</p>
<h3 id="column_name"><a class="header" href="#column_name">column_name</a></h3>
<p>The name of an output column in the <code>RETURNS TABLE</code> syntax. This is effectively another way of declaring a named <code>OUT</code> parameter, except that <code>RETURNS TABLE</code> also implies <code>RETURNS SETOF</code>.</p>
<h3 id="column_type"><a class="header" href="#column_type">column_type</a></h3>
<p>The data type of an output column in the <code>RETURNS TABLE</code> syntax.</p>
<h3 id="langname"><a class="header" href="#langname">langname</a></h3>
<p>The name of the language that the function is implemented in. May be <code>SQL</code>, <code>C</code>, <code>internal</code>, or the name of a user-defined procedural language. See <a href="CREATE_LANGUAGE.html">CREATE LANGUAGE</a> for the procedural languages supported in SynxDB. For backward compatibility, the name may be enclosed by single quotes.</p>
<h3 id="window"><a class="header" href="#window">WINDOW</a></h3>
<p><code>WINDOW</code> indicates that the function is a window function rather than a plain function. This is currently only useful for functions written in C. The <code>WINDOW</code> attribute cannot be changed when replacing an existing function definition.</p>
<h3 id="immutablestablevolatileleakproof"><a class="header" href="#immutablestablevolatileleakproof">IMMUTABLE<br/>STABLE<br/>VOLATILE<br/>LEAKPROOF</a></h3>
<p>These attributes inform the query optimizer about the behavior of the function. At most one choice may be specified. If none of these appear, <code>VOLATILE</code> is the default assumption. Since SynxDB currently has limited use of <code>VOLATILE</code> functions, if a function is truly <code>IMMUTABLE</code>, you must declare it as so to be able to use it without restrictions.</p>
<p><code>IMMUTABLE</code> indicates that the function cannot modify the database and always returns the same result when given the same argument values. It does not do database lookups or otherwise use information not directly present in its argument list. If this option is given, any call of the function with all-constant arguments can be immediately replaced with the function value.</p>
<p><code>STABLE</code> indicates that the function cannot modify the database, and that within a single table scan it will consistently return the same result for the same argument values, but that its result could change across SQL statements. This is the appropriate selection for functions whose results depend on database lookups, parameter values (such as the current time zone), and so on. Also note that the current_timestamp family of functions qualify as stable, since their values do not change within a transaction.</p>
<p><code>VOLATILE</code> indicates that the function value can change even within a single table scan, so no optimizations can be made. Relatively few database functions are volatile in this sense; some examples are <code>random()</code>, <code>timeofday()</code>. But note that any function that has side-effects must be classified volatile, even if its result is quite predictable, to prevent calls from being optimized away; an example is <code>setval()</code>.</p>
<p><code>LEAKPROOF</code> indicates that the function has no side effects. It reveals no information about its arguments other than by its return value. For example, a function that throws an error message for some argument values but not others, or that includes the argument values in any error message, is not leakproof. The query planner may push leakproof functions (but not others) into views created with the <code>security_barrier</code> option. See <a href="CREATE_VIEW.html">CREATE VIEW</a> and <a href="CREATE_RULE.html">CREATE RULE</a>. This option can only be set by the superuser.</p>
<h3 id="called-on-null-inputreturns-null-on-null-inputstrict"><a class="header" href="#called-on-null-inputreturns-null-on-null-inputstrict">CALLED ON NULL INPUT<br/>RETURNS NULL ON NULL INPUT<br/>STRICT</a></h3>
<p><code>CALLED ON NULL INPUT</code> (the default) indicates that the function will be called normally when some of its arguments are null. It is then the function author’s responsibility to check for null values if necessary and respond appropriately. <code>RETURNS NULL ON NULL INPUT</code> or <code>STRICT</code> indicates that the function always returns null whenever any of its arguments are null. If this parameter is specified, the function is not run when there are null arguments; instead a null result is assumed automatically.</p>
<h3 id="no-sqlcontains-sqlreads-sql-datamodifies-sql"><a class="header" href="#no-sqlcontains-sqlreads-sql-datamodifies-sql">NO SQL<br/>CONTAINS SQL<br/>READS SQL DATA<br/>MODIFIES SQL</a></h3>
<p>These attributes inform the query optimizer about whether or not the function contains SQL statements and whether, if it does, those statements read and/or write data.</p>
<p><code>NO SQL</code> indicates that the function does not contain SQL statements.</p>
<p><code>CONTAINS SQL</code> indicates that the function contains SQL statements, none of which either read or write data.</p>
<p><code>READS SQL DATA</code> indicates that the function contains SQL statements that read data but none that modify data.</p>
<p><code>MODIFIES SQL</code> indicates that the function contains statements that may write data.</p>
<h3 id="external-security-invokerexternal-security-definer"><a class="header" href="#external-security-invokerexternal-security-definer">[EXTERNAL] SECURITY INVOKER<br/>[EXTERNAL] SECURITY DEFINER</a></h3>
<p><code>SECURITY INVOKER</code> (the default) indicates that the function is to be run with the privileges of the user that calls it. <code>SECURITY DEFINER</code> specifies that the function is to be run with the privileges of the user that created it. The key word <code>EXTERNAL</code> is allowed for SQL conformance, but it is optional since, unlike in SQL, this feature applies to all functions not just external ones.</p>
<h3 id="execute-on-anyexecute-on-masterexecute-on-all-segmentsexecute-on-initplan"><a class="header" href="#execute-on-anyexecute-on-masterexecute-on-all-segmentsexecute-on-initplan">EXECUTE ON ANY<br/>EXECUTE ON MASTER<br/>EXECUTE ON ALL SEGMENTS<br/>EXECUTE ON INITPLAN</a></h3>
<p>The <code>EXECUTE ON</code> attributes specify where (master or segment instance) a function runs when it is invoked during the query execution process.</p>
<p><code>EXECUTE ON ANY</code> (the default) indicates that the function can be run on the master, or any segment instance, and it returns the same result regardless of where it is run. SynxDB determines where the function runs.</p>
<p><code>EXECUTE ON MASTER</code> indicates that the function must run only on the master instance.</p>
<p><code>EXECUTE ON ALL SEGMENTS</code> indicates that the function must run on all primary segment instances, but not the master, for each invocation. The overall result of the function is the <code>UNION ALL</code> of the results from all segment instances.</p>
<p><code>EXECUTE ON INITPLAN</code> indicates that the function contains an SQL command that dispatches queries to the segment instances and requires special processing on the master instance by SynxDB when possible.</p>
<pre><code>&gt; **Note** `EXECUTE ON INITPLAN` is only supported in functions that are used in the `FROM` clause of a `CREATE TABLE AS` or `INSERT` command such as the `get_data()` function in these commands.

```
CREATE TABLE t AS SELECT * FROM get_data();

INSERT INTO t1 SELECT * FROM get_data();
```

SynxDB does not support the `EXECUTE ON INITPLAN` attribute in a function that is used in the `WITH` clause of a query, a CTE \(common table expression\). For example, specifying `EXECUTE ON INITPLAN` in function `get_data()` in this CTE is not supported.

```
WITH tbl_a AS (SELECT * FROM get_data() )
   SELECT * from tbl_a
   UNION
   SELECT * FROM tbl_b;
```
</code></pre>
<p>For information about using <code>EXECUTE ON</code> attributes, see <a href="#section6">Notes</a>.</p>
<h3 id="cost-execution_cost"><a class="header" href="#cost-execution_cost">COST execution_cost</a></h3>
<p>A positive number identifying the estimated execution cost for the function, in <a href="https://www.postgresql.org/docs/9.4/runtime-config-query.html#GUC-CPU-OPERATOR-COST">cpu_operator_cost</a> units. If the function returns a set, execution_cost identifies the cost per returned row. If the cost is not specified, C-language and internal functions default to 1 unit, while functions in other languages default to 100 units. The planner tries to evaluate the function less often when you specify larger execution_cost values.</p>
<h3 id="configuration_parameter-value"><a class="header" href="#configuration_parameter-value">configuration_parameter value</a></h3>
<p>The <code>SET</code> clause applies a value to a session configuration parameter when the function is entered. The configuration parameter is restored to its prior value when the function exits. <code>SET FROM CURRENT</code> saves the value of the parameter that is current when <code>CREATE FUNCTION</code> is run as the value to be applied when the function is entered.</p>
<h3 id="definition"><a class="header" href="#definition">definition</a></h3>
<p>A string constant defining the function; the meaning depends on the language. It may be an internal function name, the path to an object file, an SQL command, or text in a procedural language.</p>
<h3 id="obj_file-link_symbol"><a class="header" href="#obj_file-link_symbol">obj_file, link_symbol</a></h3>
<p>This form of the <code>AS</code> clause is used for dynamically loadable C language functions when the function name in the C language source code is not the same as the name of the SQL function. The string obj_file is the name of the file containing the dynamically loadable object, and link_symbol is the name of the function in the C language source code. If the link symbol is omitted, it is assumed to be the same as the name of the SQL function being defined. The C names of all functions must be different, so you must give overloaded SQL functions different C names (for example, use the argument types as part of the C names). It is recommended to locate shared libraries either relative to <code>$libdir</code> (which is located at <code>$GPHOME/lib</code>) or through the dynamic library path (set by the <code>dynamic_library_path</code> server configuration parameter). This simplifies version upgrades if the new installation is at a different location.</p>
<h3 id="describe_function"><a class="header" href="#describe_function">describe_function</a></h3>
<p>The name of a callback function to run when a query that calls this function is parsed. The callback function returns a tuple descriptor that indicates the result type.</p>
<h2 id="notes"><a class="header" href="#notes"><a id="section6"></a>Notes</a></h2>
<p>Any compiled code (shared library files) for custom functions must be placed in the same location on every host in your SynxDB array (master and all segments). This location must also be in the <code>LD_LIBRARY_PATH</code> so that the server can locate the files. It is recommended to locate shared libraries either relative to <code>$libdir</code> (which is located at <code>$GPHOME/lib</code>) or through the dynamic library path (set by the <code>dynamic_library_path</code> server configuration parameter) on all master segment instances in the SynxDB array.</p>
<p>The full SQL type syntax is allowed for input arguments and return value. However, some details of the type specification (such as the precision field for type numeric) are the responsibility of the underlying function implementation and are not recognized or enforced by the <code>CREATE FUNCTION</code> command.</p>
<p>SynxDB allows function overloading. The same name can be used for several different functions so long as they have distinct input argument types. However, the C names of all functions must be different, so you must give overloaded C functions different C names (for example, use the argument types as part of the C names).</p>
<p>Two functions are considered the same if they have the same names and input argument types, ignoring any <code>OUT</code> parameters. Thus for example these declarations conflict:</p>
<pre><code>CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, out text) ...
</code></pre>
<p>Functions that have different argument type lists are not considered to conflict at creation time, but if argument defaults are provided, they might conflict in use. For example, consider:</p>
<pre><code>CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, int default 42) ...
</code></pre>
<p>The call <code>foo(10)</code>, will fail due to the ambiguity about which function should be called.</p>
<p>When repeated <code>CREATE FUNCTION</code> calls refer to the same object file, the file is only loaded once. To unload and reload the file, use the <code>LOAD</code> command.</p>
<p>You must have the <code>USAGE</code> privilege on a language to be able to define a function using that language.</p>
<p>It is often helpful to use dollar quoting to write the function definition string, rather than the normal single quote syntax. Without dollar quoting, any single quotes or backslashes in the function definition must be escaped by doubling them. A dollar-quoted string constant consists of a dollar sign (<code>$</code>), an optional tag of zero or more characters, another dollar sign, an arbitrary sequence of characters that makes up the string content, a dollar sign, the same tag that began this dollar quote, and a dollar sign. Inside the dollar-quoted string, single quotes, backslashes, or any character can be used without escaping. The string content is always written literally. For example, here are two different ways to specify the string “Dianne’s horse” using dollar quoting:</p>
<pre><code>$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$
</code></pre>
<p>If a <code>SET</code> clause is attached to a function, the effects of a <code>SET LOCAL</code> command run inside the function for the same variable are restricted to the function; the configuration parameter’s prior value is still restored when the function exits. However, an ordinary <code>SET</code> command (without <code>LOCAL</code>) overrides the <code>CREATE FUNCTION</code> <code>SET</code> clause, much as it would for a previous <code>SET LOCAL</code> command. The effects of such a command will persist after the function exits, unless the current transaction is rolled back.</p>
<p>If a function with a <code>VARIADIC</code> argument is declared as <code>STRICT</code>, the strictness check tests that the variadic array as a whole is non-null. PL/pgSQL will still call the function if the array has null elements.</p>
<p>When replacing an existing function with <code>CREATE OR REPLACE FUNCTION</code>, there are restrictions on changing parameter names. You cannot change the name already assigned to any input parameter (although you can add names to parameters that had none before). If there is more than one output parameter, you cannot change the names of the output parameters, because that would change the column names of the anonymous composite type that describes the function’s result. These restrictions are made to ensure that existing calls of the function do not stop working when it is replaced.</p>
<p><strong>Using Functions with Queries on Distributed Data</strong></p>
<p>In some cases, SynxDB does not support using functions in a query where the data in a table specified in the <code>FROM</code> clause is distributed over SynxDB segments. As an example, this SQL query contains the function <code>func()</code>:</p>
<pre><code>SELECT func(a) FROM table1;
</code></pre>
<p>The function is not supported for use in the query if all of the following conditions are met:</p>
<ul>
<li>The data of table <code>table1</code> is distributed over SynxDB segments.</li>
<li>The function <code>func()</code> reads or modifies data from distributed tables.</li>
<li>The function <code>func()</code> returns more than one row or takes an argument (<code>a</code>) that comes from <code>table1</code>.</li>
</ul>
<p>If any of the conditions are not met, the function is supported. Specifically, the function is supported if any of the following conditions apply:</p>
<ul>
<li>The function <code>func()</code> does not access data from distributed tables, or accesses data that is only on the SynxDB master.</li>
<li>The table <code>table1</code> is a master only table.</li>
<li>The function <code>func()</code> returns only one row and only takes input arguments that are constant values. The function is supported if it can be changed to require no input arguments.</li>
</ul>
<p><strong>Using EXECUTE ON attributes</strong></p>
<p>Most functions that run queries to access tables can only run on the master. However, functions that run only <code>SELECT</code> queries on replicated tables can run on segments. If the function accesses a hash-distributed table or a randomly distributed table, the function should be defined with the <code>EXECUTE ON MASTER</code> attribute. Otherwise, the function might return incorrect results when the function is used in a complicated query. Without the attribute, planner optimization might determine it would be beneficial to push the function invocation to segment instances.</p>
<p>These are limitations for functions defined with the <code>EXECUTE ON MASTER</code> or <code>EXECUTE ON ALL SEGMENTS</code> attribute:</p>
<ul>
<li>The function must be a set-returning function.</li>
<li>The function cannot be in the <code>FROM</code> clause of a query.</li>
<li>The function cannot be in the <code>SELECT</code> list of a query with a <code>FROM</code> clause.</li>
<li>A query that includes the function falls back from GPORCA to the Postgres Planner.</li>
</ul>
<p>The attribute <code>EXECUTE ON INITPLAN</code> indicates that the function contains an SQL command that dispatches queries to the segment instances and requires special processing on the master instance by SynxDB. When possible, SynxDB handles the function on the master instance in the following manner.</p>
<ol>
<li>First, SynxDB runs the function as part of an InitPlan node on the master instance and holds the function output temporarily.</li>
<li>Then, in the MainPlan of the query plan, the function is called in an EntryDB (a special query executor (QE) that runs on the master instance) and SynxDB returns the data that was captured when the function was run as part of the InitPlan node. The function is not run in the MainPlan.</li>
</ol>
<p>This simple example uses the function <code>get_data()</code> in a CTAS command to create a table using data from the table <code>country</code>. The function contains a <code>SELECT</code> command that retrieves data from the table <code>country</code> and uses the <code>EXECUTE ON INITPLAN</code> attribute.</p>
<pre><code>CREATE TABLE country( 
  c_id integer, c_name text, region int) 
  DISTRIBUTED RANDOMLY;

INSERT INTO country VALUES (11,'INDIA', 1 ), (22,'CANADA', 2), (33,'USA', 3);

CREATE OR REPLACE FUNCTION get_data()
  RETURNS TABLE (
   c_id integer, c_name text
   )
AS $$
  SELECT
    c.c_id, c.c_name
  FROM
    country c;
$$
LANGUAGE SQL EXECUTE ON INITPLAN;

CREATE TABLE t AS SELECT * FROM get_data() DISTRIBUTED RANDOMLY;
</code></pre>
<p>If you view the query plan of the CTAS command with <code>EXPLAIN ANALYZE VERBOSE</code>, the plan shows that the function is run as part of an InitPlan node, and one of the listed slices is labeled as <code>entry db</code>. The query plan of a simple CTAS command without the function does not have an InitPlan node or an <code>entry db</code> slice.</p>
<p>If the function did not contain the <code>EXECUTE ON INITPLAN</code> attribute, the CTAS command returns the error <code>function cannot execute on a QE slice</code>.</p>
<p>When a function uses the <code>EXECUTE ON INITPLAN</code> attribute, a command that uses the function such as <code>CREATE TABLE t AS SELECT * FROM get_data()</code> gathers the results of the function onto the master segment and then redistributes the results to segment instances when inserting the data. If the function returns a large amount of data, the master might become a bottleneck when gathering and redistributing data. Performance might improve if you rewrite the function to run the CTAS command in the user defined function and use the table name as an input parameter. In this example, the function runs a CTAS command and does not require the <code>EXECUTE ON INITPLAN</code> attribute. Running the <code>SELECT</code> command creates the table <code>t1</code> using the function that runs the CTAS command.</p>
<pre><code>CREATE OR REPLACE FUNCTION my_ctas(_tbl text) RETURNS VOID AS
$$
BEGIN
  EXECUTE format('CREATE TABLE %s AS SELECT c.c_id, c.c_name FROM country c DISTRIBUTED RANDOMLY', _tbl);
END
$$
LANGUAGE plpgsql;

SELECT my_ctas('t1');
</code></pre>
<h2 id="examples"><a class="header" href="#examples"><a id="section8"></a>Examples</a></h2>
<p>A very simple addition function:</p>
<pre><code>CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
</code></pre>
<p>Increment an integer, making use of an argument name, in PL/pgSQL:</p>
<pre><code>CREATE OR REPLACE FUNCTION increment(i integer) RETURNS 
integer AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;
</code></pre>
<p>Increase the default segment host memory per query for a PL/pgSQL function:</p>
<pre><code>CREATE OR REPLACE FUNCTION function_with_query() RETURNS 
SETOF text AS $$
        BEGIN
                RETURN QUERY
                EXPLAIN ANALYZE SELECT * FROM large_table;
        END;
$$ LANGUAGE plpgsql
SET statement_mem='256MB';
</code></pre>
<p>Use polymorphic types to return an <code>ENUM</code> array:</p>
<pre><code>CREATE TYPE rainbow AS ENUM('red','orange','yellow','green','blue','indigo','violet');
CREATE FUNCTION return_enum_as_array( anyenum, anyelement, anyelement ) 
    RETURNS TABLE (ae anyenum, aa anyarray) AS $$
    SELECT $1, array[$2, $3] 
$$ LANGUAGE SQL STABLE;

SELECT * FROM return_enum_as_array('red'::rainbow, 'green'::rainbow, 'blue'::rainbow);
</code></pre>
<p>Return a record containing multiple output parameters:</p>
<pre><code>CREATE FUNCTION dup(in int, out f1 int, out f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</code></pre>
<p>You can do the same thing more verbosely with an explicitly named composite type:</p>
<pre><code>CREATE TYPE dup_result AS (f1 int, f2 text);
CREATE FUNCTION dup(int) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</code></pre>
<p>Another way to return multiple columns is to use a <code>TABLE</code> function:</p>
<pre><code>CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(4);

</code></pre>
<p>This function is defined with the <code>EXECUTE ON ALL SEGMENTS</code> to run on all primary segment instances. The <code>SELECT</code> command runs the function that returns the time it was run on each segment instance.</p>
<pre><code>CREATE FUNCTION run_on_segs (text) returns setof text as $$
  begin 
    return next ($1 || ' - ' || now()::text ); 
  end;
 $$ language plpgsql VOLATILE EXECUTE ON ALL SEGMENTS;

SELECT run_on_segs('my test');
</code></pre>
<p>This function looks up a part name in the parts table. The parts table is replicated, so the function can run on the master or on the primary segments.</p>
<pre><code>CREATE OR REPLACE FUNCTION get_part_name(partno int) RETURNS text AS
$$
DECLARE
   result text := ' ';
BEGIN
    SELECT part_name INTO result FROM parts WHERE part_id = partno;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
</code></pre>
<p>If you run <code>SELECT get_part_name(100);</code> at the master the function runs on the master. (The master instance directs the query to a single primary segment.) If orders is a distributed table and you run the following query, the <code>get_part_name()</code> function runs on the primary segments.</p>
<pre><code>`SELECT order_id, get_part_name(orders.part_no) FROM orders;`
</code></pre>
<h2 id="compatibility"><a class="header" href="#compatibility"><a id="section9"></a>Compatibility</a></h2>
<p><code>CREATE FUNCTION</code> is defined in SQL:1999 and later. The SynxDB version is similar but not fully compatible. The attributes are not portable, neither are the different available languages.</p>
<p>For compatibility with some other database systems, argmode can be written either before or after argname. But only the first way is standard-compliant.</p>
<p>For parameter defaults, the SQL standard specifies only the syntax with the <code>DEFAULT</code> key word. The syntax with <code>=</code> is used in T-SQL and Firebird.</p>
<h2 id="see-also"><a class="header" href="#see-also"><a id="section10"></a>See Also</a></h2>
<p><a href="ALTER_FUNCTION.html">ALTER FUNCTION</a>, <a href="DROP_FUNCTION.html">DROP FUNCTION</a>, <a href="LOAD.html">LOAD</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../ref_guide/sql_commands/CREATE_FOREIGN_TABLE.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../ref_guide/sql_commands/CREATE_GROUP.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../ref_guide/sql_commands/CREATE_FOREIGN_TABLE.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../ref_guide/sql_commands/CREATE_GROUP.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
