<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CREATE TABLE - SynxDB 2 Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SynxDB 2 Documentation</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                        &nbsp;&nbsp;&nbsp;&nbsp;
                        <a href="https://www.synxdata.com/"><img id="fa fa-print" src="../../SYNX-Text-and-Circular-Logo-142x28-White-text-Black-background.png" alt="Synx Data Labs Logo"/></a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="create-table"><a class="header" href="#create-table">CREATE TABLE</a></h1>
<p>Defines a new table.</p>
<blockquote>
<p><strong>Note</strong> Referential integrity syntax (foreign key constraints) is accepted but not enforced.</p>
</blockquote>
<h2 id="synopsis"><a class="header" href="#synopsis"><a id="section2"></a>Synopsis</a></h2>
<pre><code class="language-{#sql_command_synopsis}">
CREATE [ [GLOBAL | LOCAL] {TEMPORARY | TEMP } | UNLOGGED] TABLE [IF NOT EXISTS] 
  &lt;table_name&gt; ( 
  [ { &lt;column_name&gt; &lt;data_type&gt; [ COLLATE &lt;collation&gt; ] [&lt;column_constraint&gt; [ ... ] ]
[ ENCODING ( &lt;storage_directive&gt; [, ...] ) ]
    | &lt;table_constraint&gt;
    | LIKE &lt;source_table&gt; [ &lt;like_option&gt; ... ] }
    | [ &lt;column_reference_storage_directive&gt; [, ...]
    [, ... ]
] )
[ INHERITS ( &lt;parent_table&gt; [, ... ] ) ]
[ WITH ( &lt;storage_parameter&gt; [=&lt;value&gt;] [, ... ] ) ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE &lt;tablespace_name&gt; ]
[ DISTRIBUTED BY (&lt;column&gt; [&lt;opclass&gt;], [ ... ] ) 
       | DISTRIBUTED RANDOMLY | DISTRIBUTED REPLICATED ]

{ --partitioned table using SUBPARTITION TEMPLATE
[ PARTITION BY &lt;partition_type&gt; (&lt;column&gt;) 
  {  [ SUBPARTITION BY &lt;partition_type&gt; (&lt;column1&gt;) 
       SUBPARTITION TEMPLATE ( &lt;template_spec&gt; ) ]
          [ SUBPARTITION BY partition_type (&lt;column2&gt;) 
            SUBPARTITION TEMPLATE ( &lt;template_spec&gt; ) ]
              [...]  }
  ( &lt;partition_spec&gt; ) ]
} |

{ -- partitioned table without SUBPARTITION TEMPLATE
[ PARTITION BY &lt;partition_type&gt; (&lt;column&gt;)
   [ SUBPARTITION BY &lt;partition_type&gt; (&lt;column1&gt;) ]
      [ SUBPARTITION BY &lt;partition_type&gt; (&lt;column2&gt;) ]
         [...]
  ( &lt;partition_spec&gt;
     [ ( &lt;subpartition_spec_column1&gt;
          [ ( &lt;subpartition_spec_column2&gt;
               [...] ) ] ) ],
  [ &lt;partition_spec&gt;
     [ ( &lt;subpartition_spec_column1&gt;
        [ ( &lt;subpartition_spec_column2&gt;
             [...] ) ] ) ], ]
    [...]
  ) ]
}

CREATE [ [GLOBAL | LOCAL] {TEMPORARY | TEMP} | UNLOGGED ] TABLE [IF NOT EXISTS] 
   &lt;table_name&gt;
    OF &lt;type_name&gt; [ (
  { &lt;column_name&gt; WITH OPTIONS [ &lt;column_constraint&gt; [ ... ] ]
    | &lt;table_constraint&gt; } 
    [, ... ]
) ]
[ WITH ( &lt;storage_parameter&gt; [=&lt;value&gt;] [, ... ] ) ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE &lt;tablespace_name&gt; ]

</code></pre>
<p>where column_constraint is:</p>
<pre><code>[ CONSTRAINT &lt;constraint_name&gt;]
{ NOT NULL 
  | NULL 
  | CHECK  ( &lt;expression&gt; ) [ NO INHERIT ]
  | DEFAULT &lt;default_expr&gt;
  | UNIQUE &lt;index_parameters&gt;
  | PRIMARY KEY &lt;index_parameters&gt;
  | REFERENCES &lt;reftable&gt; [ ( refcolumn ) ] 
      [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]  
      [ ON DELETE &lt;key_action&gt; ] [ ON UPDATE &lt;key_action&gt; ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
</code></pre>
<p>and table_constraint is:</p>
<pre><code>[ CONSTRAINT &lt;constraint_name&gt; ]
{ CHECK ( &lt;expression&gt; ) [ NO INHERIT ]
  | UNIQUE ( &lt;column_name&gt; [, ... ] ) &lt;index_parameters&gt;
  | PRIMARY KEY ( &lt;column_name&gt; [, ... ] ) &lt;index_parameters&gt;
  | FOREIGN KEY ( &lt;column_name&gt; [, ... ] ) 
      REFERENCES &lt;reftable&gt; [ ( &lt;refcolumn&gt; [, ... ] ) ]
      [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] 
      [ ON DELETE &lt;key_action&gt; ] [ ON UPDATE &lt;key_action&gt; ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
</code></pre>
<p>and <em>like_option</em> is:</p>
<pre><code class="language-pre">{INCLUDING|EXCLUDING} {DEFAULTS|CONSTRAINTS|INDEXES|STORAGE|COMMENTS|ALL}
</code></pre>
<p>and index_parameters in <code>UNIQUE</code> and <code>PRIMARY KEY</code> constraints are:</p>
<pre><code>[ WITH ( &lt;storage_parameter&gt; [=&lt;value&gt;] [, ... ] ) ]
[ USING INDEX TABLESPACE &lt;tablespace_name&gt; ] 
</code></pre>
<p>and storage_directive for a column is:</p>
<pre><code>   compresstype={ZLIB|ZSTD|RLE_TYPE|NONE}
    [compresslevel={0-9}]
    [blocksize={8192-2097152} ]
</code></pre>
<p>and storage_parameter for the table is:</p>
<pre><code>   appendoptimized={TRUE|FALSE}
   blocksize={8192-2097152}
   orientation={COLUMN|ROW}
   checksum={TRUE|FALSE}
   compresstype={ZLIB|ZSTD|RLE_TYPE|NONE}
   compresslevel={0-9}
   fillfactor={10-100}
   analyze_hll_non_part_table={TRUE|FALSE}
   [oids=FALSE]
</code></pre>
<p>and key_action is:</p>
<pre><code>    ON DELETE 
  | ON UPDATE
  | NO ACTION
  | RESTRICT
  | CASCADE
  | SET NULL
  | SET DEFAULT
</code></pre>
<p>and partition_type is:</p>
<pre><code>    LIST | RANGE
</code></pre>
<p>and partition_specification is:</p>
<pre><code>&lt;partition_element&gt; [, ...]
</code></pre>
<p>and partition_element is:</p>
<pre><code>   DEFAULT PARTITION &lt;name&gt;
  | [PARTITION &lt;name&gt;] VALUES (&lt;list_value&gt; [,...] )
  | [PARTITION &lt;name&gt;] 
     START ([&lt;datatype&gt;] '&lt;start_value&gt;') [INCLUSIVE | EXCLUSIVE]
     [ END ([&lt;datatype&gt;] '&lt;end_value&gt;') [INCLUSIVE | EXCLUSIVE] ]
     [ EVERY ([&lt;datatype&gt;] [&lt;number | &gt;INTERVAL] '&lt;interval_value&gt;') ]
  | [PARTITION &lt;name&gt;] 
     END ([&lt;datatype&gt;] '&lt;end_value&gt;') [INCLUSIVE | EXCLUSIVE]
     [ EVERY ([&lt;datatype&gt;] [&lt;number | &gt;INTERVAL] '&lt;interval_value&gt;') ]
[ WITH ( &lt;partition_storage_parameter&gt;=&lt;value&gt; [, ... ] ) ]
[ &lt;column_reference_storage_directive&gt; [, ...] ]
[ TABLESPACE &lt;tablespace&gt; ]
</code></pre>
<p>where subpartition_spec or template_spec is:</p>
<pre><code>&lt;subpartition_element&gt; [, ...]
</code></pre>
<p>and subpartition_element is:</p>
<pre><code>   DEFAULT SUBPARTITION &lt;name&gt;
  | [SUBPARTITION &lt;name&gt;] VALUES (&lt;list_value&gt; [,...] )
  | [SUBPARTITION &lt;name&gt;] 
     START ([&lt;datatype&gt;] '&lt;start_value&gt;') [INCLUSIVE | EXCLUSIVE]
     [ END ([&lt;datatype&gt;] '&lt;end_value&gt;') [INCLUSIVE | EXCLUSIVE] ]
     [ EVERY ([&lt;datatype&gt;] [&lt;number | &gt;INTERVAL] '&lt;interval_value&gt;') ]
  | [SUBPARTITION &lt;name&gt;] 
     END ([&lt;datatype&gt;] '&lt;end_value&gt;') [INCLUSIVE | EXCLUSIVE]
     [ EVERY ([&lt;datatype&gt;] [&lt;number | &gt;INTERVAL] '&lt;interval_value&gt;') ]
[ WITH ( &lt;partition_storage_parameter&gt;=&lt;value&gt; [, ... ] ) ]
[ &lt;column_reference_storage_directive&gt; [, ...] ]
[ TABLESPACE &lt;tablespace&gt; ]
</code></pre>
<p>where storage_parameter for a partition is:</p>
<pre><code>   appendoptimized={TRUE|FALSE}
   blocksize={8192-2097152}
   orientation={COLUMN|ROW}
   checksum={TRUE|FALSE}
   compresstype={ZLIB|ZSTD|RLE_TYPE|NONE}
   compresslevel={1-19}
   fillfactor={10-100}
   [oids=FALSE]
</code></pre>
<h2 id="description"><a class="header" href="#description"><a id="section3"></a>Description</a></h2>
<p><code>CREATE TABLE</code> creates an initially empty table in the current database. The user who issues the command owns the table.</p>
<p>To be able to create a table, you must have <code>USAGE</code> privilege on all column types or the type in the <code>OF</code> clause, respectively.</p>
<p>If you specify a schema name, SynxDB creates the table in the specified schema. Otherwise SynxDB creates the table in the current schema. Temporary tables exist in a special schema, so you cannot specify a schema name when creating a temporary table. Table names must be distinct from the name of any other table, external table, sequence, index, view, or foreign table in the same schema.</p>
<p><code>CREATE TABLE</code> also automatically creates a data type that represents the composite type corresponding to one row of the table. Therefore, tables cannot have the same name as any existing data type in the same schema.</p>
<p>The optional constraint clauses specify conditions that new or updated rows must satisfy for an insert or update operation to succeed. A constraint is an SQL object that helps define the set of valid values in the table in various ways. Constraints apply to tables, not to partitions. You cannot add a constraint to a partition or subpartition.</p>
<p>Referential integrity constraints (foreign keys) are accepted but not enforced. The information is kept in the system catalogs but is otherwise ignored.</p>
<p>There are two ways to define constraints: table constraints and column constraints. A column constraint is defined as part of a column definition. A table constraint definition is not tied to a particular column, and it can encompass more than one column. Every column constraint can also be written as a table constraint; a column constraint is only a notational convenience for use when the constraint only affects one column.</p>
<p>When creating a table, there is an additional clause to declare the SynxDB distribution policy. If a <code>DISTRIBUTED BY</code>, <code>DISTRIBUTED RANDOMLY</code>, or <code>DISTRIBUTED REPLICATED</code> clause is not supplied, then SynxDB assigns a hash distribution policy to the table using either the <code>PRIMARY KEY</code> (if the table has one) or the first column of the table as the distribution key. Columns of geometric or user-defined data types are not eligible as SynxDB distribution key columns. If a table does not have a column of an eligible data type, the rows are distributed based on a round-robin or random distribution. To ensure an even distribution of data in your SynxDB system, you want to choose a distribution key that is unique for each record, or if that is not possible, then choose <code>DISTRIBUTED RANDOMLY</code>.</p>
<p>If the <code>DISTRIBUTED REPLICATED</code> clause is supplied, SynxDB distributes all rows of the table to all segments in the SynxDB system. This option can be used in cases where user-defined functions must run on the segments, and the functions require access to all rows of the table. Replicated functions can also be used to improve query performance by preventing broadcast motions for the table. The <code>DISTRIBUTED REPLICATED</code> clause cannot be used with the <code>PARTITION BY</code> clause or the <code>INHERITS</code> clause. A replicated table also cannot be inherited by another table. The hidden system columns (<code>ctid</code>, <code>cmin</code>, <code>cmax</code>, <code>xmin</code>, <code>xmax</code>, and <code>gp_segment_id</code>) cannot be referenced in user queries on replicated tables because they have no single, unambiguous value. SynxDB returns a <code>column does not exist</code> error for the query.</p>
<p>The <code>PARTITION BY</code> clause allows you to divide the table into multiple sub-tables (or parts) that, taken together, make up the parent table and share its schema. Though the sub-tables exist as independent tables, the SynxDB restricts their use in important ways. Internally, partitioning is implemented as a special form of inheritance. Each child table partition is created with a distinct <code>CHECK</code> constraint which limits the data the table can contain, based on some defining criteria. The <code>CHECK</code> constraints are also used by the query optimizer to determine which table partitions to scan in order to satisfy a given query predicate. These partition constraints are managed automatically by the SynxDB.</p>
<h2 id="parameters"><a class="header" href="#parameters"><a id="section4"></a>Parameters</a></h2>
<p>These keywords are present for SQL standard compatibility, but have no effect in SynxDB and are deprecated.</p>
<p>If specified, the table is created as a temporary table. Temporary tables are automatically dropped at the end of a session, or optionally at the end of the current transaction (see <code>ON COMMIT</code>). Existing permanent tables with the same name are not visible to the current session while the temporary table exists, unless they are referenced with schema-qualified names. Any indexes created on a temporary table are automatically temporary as well.</p>
<p>If specified, the table is created as an unlogged table. Data written to unlogged tables is not written to the write-ahead (WAL) log, which makes them considerably faster than ordinary tables. However, the contents of an unlogged table are not replicated to mirror segment instances. Also an unlogged table is not crash-safe. After a segment instance crash or unclean shutdown, the data for the unlogged table on that segment is truncated. Any indexes created on an unlogged table are automatically unlogged as well.</p>
<p>The name (optionally schema-qualified) of the table to be created.</p>
<p>Creates a typed table, which takes its structure from the specified composite type (name optionally schema-qualified). A typed table is tied to its type; for example the table will be dropped if the type is dropped (with <code>DROP TYPE ... CASCADE</code>).</p>
<p>When a typed table is created, the data types of the columns are determined by the underlying composite type and are not specified by the <code>CREATE TABLE</code> command. But the <code>CREATE TABLE</code> command can add defaults and constraints to the table and can specify storage parameters.</p>
<p>The name of a column to be created in the new table.</p>
<p>The data type of the column. This may include array specifiers.</p>
<p>For table columns that contain textual data, Specify the data type <code>VARCHAR</code> or <code>TEXT</code>. Specifying the data type <code>CHAR</code> is not recommended. In SynxDB, the data types <code>VARCHAR</code> or <code>TEXT</code> handles padding added to the data (space characters added after the last non-space character) as significant characters, the data type <code>CHAR</code> does not. See <a href="#section5">Notes</a>.</p>
<p>The <code>COLLATE</code> clause assigns a collation to the column (which must be of a collatable data type). If not specified, the column data type’s default collation is used.</p>
<pre><code>&gt; **Note** GPORCA supports collation only when all columns in the query use the same collation. If columns in the query use different collations, then SynxDB uses the Postgres Planner.
</code></pre>
<p>The <code>DEFAULT</code> clause assigns a default data value for the column whose column definition it appears within. The value is any variable-free expression (subqueries and cross-references to other columns in the current table are not allowed). The data type of the default expression must match the data type of the column. The default expression will be used in any insert operation that does not specify a value for the column. If there is no default for a column, then the default is null.</p>
<p>For a column, the optional <code>ENCODING</code> clause specifies the type of compression and block size for the column data. See <code>storage_options</code> for <code>compresstype</code>, <code>compresslevel</code>, and <code>blocksize</code> values.</p>
<p>The clause is valid only for append-optimized, column-oriented tables.</p>
<p>Column compression settings are inherited from the table level to the partition level to the subpartition level. The lowest-level settings have priority.</p>
<p>The optional <code>INHERITS</code> clause specifies a list of tables from which the new table automatically inherits all columns. Use of <code>INHERITS</code> creates a persistent relationship between the new child table and its parent table(s). Schema modifications to the parent(s) normally propagate to children as well, and by default the data of the child table is included in scans of the parent(s).</p>
<p>In SynxDB, the <code>INHERITS</code> clause is not used when creating partitioned tables. Although the concept of inheritance is used in partition hierarchies, the inheritance structure of a partitioned table is created using the <a href="#part_by">PARTITION BY</a> clause.</p>
<p>If the same column name exists in more than one parent table, an error is reported unless the data types of the columns match in each of the parent tables. If there is no conflict, then the duplicate columns are merged to form a single column in the new table. If the column name list of the new table contains a column name that is also inherited, the data type must likewise match the inherited column(s), and the column definitions are merged into one. If the new table explicitly specifies a default value for the column, this default overrides any defaults from inherited declarations of the column. Otherwise, any parents that specify default values for the column must all specify the same default, or an error will be reported.</p>
<p><code>CHECK</code> constraints are merged in essentially the same way as columns: if multiple parent tables or the new table definition contain identically-named <code>constraints</code>, these constraints must all have the same check expression, or an error will be reported. Constraints having the same name and expression will be merged into one copy. A constraint marked <code>NO INHERIT</code> in a parent will not be considered. Notice that an unnamed <code>CHECK</code> constraint in the new table will never be merged, since a unique name will always be chosen for it.</p>
<p>Column <code>STORAGE</code> settings are also copied from parent tables.</p>
<p>The <code>LIKE</code> clause specifies a table from which the new table automatically copies all column names, their data types, not-null constraints, and distribution policy. Unlike <code>INHERITS</code>, the new table and original table are completely decoupled after creation is complete.</p>
<blockquote>
<p><strong>Note</strong> Storage properties like append-optimized or partition structure are not copied.</p>
</blockquote>
<p>Default expressions for the copied column definitions will only be copied if <code>INCLUDING DEFAULTS</code> is specified. The default behavior is to exclude default expressions, resulting in the copied columns in the new table having null defaults.</p>
<p>Not-null constraints are always copied to the new table. <code>CHECK</code> constraints will be copied only if <code>INCLUDING CONSTRAINTS</code> is specified. No distinction is made between column constraints and table constraints.</p>
<p>Indexes, <code>PRIMARY KEY</code>, and <code>UNIQUE</code> constraints on the original table will be created on the new table only if the <code>INCLUDING INDEXES</code> clause is specified. Names for the new indexes and constraints are chosen according to the default rules, regardless of how the originals were named. (This behavior avoids possible duplicate-name failures for the new indexes.)</p>
<p>Any indexes on the original table will not be created on the new table, unless the <code>INCLUDING INDEXES</code> clause is specified.</p>
<p><code>STORAGE</code> settings for the copied column definitions will be copied only if <code>INCLUDING STORAGE</code> is specified. The default behavior is to exclude <code>STORAGE</code> settings, resulting in the copied columns in the new table having type-specific default settings.</p>
<p>Comments for the copied columns, constraints, and indexes will be copied only if <code>INCLUDING COMMENTS</code> is specified. The default behavior is to exclude comments, resulting in the copied columns and constraints in the new table having no comments.</p>
<p><code>INCLUDING ALL</code> is an abbreviated form of <code>INCLUDING DEFAULTS INCLUDING CONSTRAINTS INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS</code>.</p>
<p>Note that unlike <code>INHERITS</code>, columns and constraints copied by <code>LIKE</code> are not merged with similarly named columns and constraints. If the same name is specified explicitly or in another <code>LIKE</code> clause, an error is signaled.</p>
<p>The <code>LIKE</code> clause can also be used to copy columns from views, foreign tables, or composite types. Inapplicable options (e.g., <code>INCLUDING INDEXES</code> from a view) are ignored.</p>
<p>An optional name for a column or table constraint. If the constraint is violated, the constraint name is present in error messages, so constraint names like column must be positive can be used to communicate helpful constraint information to client applications. (Double-quotes are needed to specify constraint names that contain spaces.) If a constraint name is not specified, the system generates a name.</p>
<pre><code>&gt; **Note** The specified constraint\_name is used for the constraint, but a system-generated unique name is used for the index name. In some prior releases, the provided name was used for both the constraint name and the index name.
</code></pre>
<p>Specifies if the column is or is not allowed to contain null values. <code>NULL</code> is the default.</p>
<p>The <code>CHECK</code> clause specifies an expression producing a Boolean result which new or updated rows must satisfy for an insert or update operation to succeed. Expressions evaluating to <code>TRUE</code> or <code>UNKNOWN</code> succeed. Should any row of an insert or update operation produce a <code>FALSE</code> result an error exception is raised and the insert or update does not alter the database. A check constraint specified as a column constraint should reference that column’s value only, while an expression appearing in a table constraint can reference multiple columns.</p>
<p>A constraint marked with <code>NO INHERIT</code> will not propagate to child tables.</p>
<p>Currently, <code>CHECK</code> expressions cannot contain subqueries nor refer to variables other than columns of the current row.</p>
<p>The <code>UNIQUE</code> constraint specifies that a group of one or more columns of a table may contain only unique values. The behavior of the unique table constraint is the same as that for column constraints, with the additional capability to span multiple columns. For the purpose of a unique constraint, null values are not considered equal. The column(s) that are unique must contain all the columns of the SynxDB distribution key. In addition, the <code>&lt;key&gt;</code> must contain all the columns in the partition key if the table is partitioned. Note that a <code>&lt;key&gt;</code> constraint in a partitioned table is not the same as a simple <code>UNIQUE INDEX</code>.</p>
<p>For information about unique constraint management and limitations, see <a href="#section5">Notes</a>.</p>
<p>The <code>PRIMARY KEY</code> constraint specifies that a column or columns of a table may contain only unique (non-duplicate), non-null values. Only one primary key can be specified for a table, whether as a column constraint or a table constraint.</p>
<p>For a table to have a primary key, it must be hash distributed (not randomly distributed), and the primary key, the column(s) that are unique, must contain all the columns of the SynxDB distribution key. In addition, the <code>&lt;key&gt;</code> must contain all the columns in the partition key if the table is partitioned. Note that a <code>&lt;key&gt;</code> constraint in a partitioned table is not the same as a simple <code>UNIQUE INDEX</code>.</p>
<p><code>PRIMARY KEY</code> enforces the same data constraints as a combination of <code>UNIQUE</code> and <code>NOT NULL</code>, but identifying a set of columns as the primary key also provides metadata about the design of the schema, since a primary key implies that other tables can rely on this set of columns as a unique identifier for rows.</p>
<p>For information about primary key management and limitations, see <a href="#section5">Notes</a>.</p>
<h3 id="references-reftable---refcolumn---match-full--match-partial--match-simple-on-delete--on-update-key_actionforeign-key-column_name--"><a class="header" href="#references-reftable---refcolumn---match-full--match-partial--match-simple-on-delete--on-update-key_actionforeign-key-column_name--">REFERENCES reftable [ ( refcolumn ) ]<br/>[ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]<br/>[ON DELETE | ON UPDATE] [key_action]<br/>FOREIGN KEY (column_name [, …])</a></h3>
<p>The <code>REFERENCES</code> and <code>FOREIGN KEY</code> clauses specify referential integrity constraints (foreign key constraints). SynxDB accepts referential integrity constraints as specified in PostgreSQL syntax but does not enforce them. See the PostgreSQL documentation for information about referential integrity constraints.</p>
<h3 id="deferrablenot-deferrable"><a class="header" href="#deferrablenot-deferrable">DEFERRABLE<br/>NOT DEFERRABLE</a></h3>
<p>The <code>[NOT] DEFERRABLE</code> clause controls whether the constraint can be deferred. A constraint that is not deferrable will be checked immediately after every command. Checking of constraints that are deferrable can be postponed until the end of the transaction (using the <a href="SET_CONSTRAINTS.html"><code>SET CONSTRAINTS</code></a> command). <code>NOT DEFERRABLE</code> is the default. Currently, only <code>UNIQUE</code> and <code>PRIMARY KEY</code> constraints are deferrable. <code>NOT NULL</code> and <code>CHECK</code> constraints are not deferrable. <code>REFERENCES</code> (foreign key) constraints accept this clause but are not enforced.</p>
<h3 id="initially-immediateinitially-deferred"><a class="header" href="#initially-immediateinitially-deferred">INITIALLY IMMEDIATE<br/>INITIALLY DEFERRED</a></h3>
<p>If a constraint is deferrable, this clause specifies the default time to check the constraint. If the constraint is <code>INITIALLY IMMEDIATE</code>, it is checked after each statement. This is the default. If the constraint is <code>INITIALLY DEFERRED</code>, it is checked only at the end of the transaction. The constraint check time can be altered with the <code>SET CONSTRAINTS</code> command.</p>
<h3 id="with--storage_parametervalue-"><a class="header" href="#with--storage_parametervalue-">WITH ( storage_parameter=value )</a></h3>
<p>The <code>WITH</code> clause can specify storage parameters for tables, and for indexes associated with a <code>UNIQUE</code> or <code>PRIMARY</code> constraint. Note that you can also set storage parameters on a particular partition or subpartition by declaring the <code>WITH</code> clause in the partition specification. The lowest-level settings have priority.</p>
<p>The defaults for some of the table storage options can be specified with the server configuration parameter <code>gp_default_storage_options</code>. For information about setting default storage options, see <a href="#section5">Notes</a>.</p>
<p>The following storage options are available:</p>
<p><strong>appendoptimized</strong> — Set to <code>TRUE</code> to create the table as an append-optimized table. If <code>FALSE</code> or not declared, the table will be created as a regular heap-storage table.</p>
<p><strong>blocksize</strong> — Set to the size, in bytes, for each block in a table. The <code>blocksize</code> must be between 8192 and 2097152 bytes, and be a multiple of 8192. The default is 32768. The <code>blocksize</code> option is valid only if <code>appendoptimized=TRUE</code>.</p>
<p><strong>orientation</strong> — Set to <code>column</code> for column-oriented storage, or <code>row</code> (the default) for row-oriented storage. This option is only valid if <code>appendoptimized=TRUE</code>. Heap-storage tables can only be row-oriented.</p>
<p><strong>checksum</strong> — This option is valid only for append-optimized tables (<code>appendoptimized=TRUE</code>). The value <code>TRUE</code> is the default and enables CRC checksum validation for append-optimized tables. The checksum is calculated during block creation and is stored on disk. Checksum validation is performed during block reads. If the checksum calculated during the read does not match the stored checksum, the transaction is cancelled. If you set the value to <code>FALSE</code> to deactivate checksum validation, checking the table data for on-disk corruption will not be performed.</p>
<p><strong>compresstype</strong> — Set to <code>ZLIB</code> (the default), <code>ZSTD</code>, or <code>RLE_TYPE</code> to specify the type of compression used. The value <code>NONE</code> deactivates compression. Zstd provides for both speed or a good compression ratio, tunable with the <code>compresslevel</code> option. Zstd outperforms these compression types on usual workloads. The <code>compresstype</code> option is only valid if <code>appendoptimized=TRUE</code>.</p>
<pre><code>The value `RLE_TYPE`, which is supported only if `orientation`=`column` is specified, enables the run-length encoding \(RLE\) compression algorithm. RLE compresses data better than the Zstd, or zlib compression algorithms when the same data value occurs in many consecutive rows.

For columns of type `BIGINT`, `INTEGER`, `DATE`, `TIME`, or `TIMESTAMP`, delta compression is also applied if the `compresstype` option is set to `RLE_TYPE` compression. The delta compression algorithm is based on the delta between column values in consecutive rows and is designed to improve compression when data is loaded in sorted order or the compression is applied to column data that is in sorted order.

For information about using table compression, see [Choosing the Table Storage Model](../../admin_guide/ddl/ddl-storage.html) in the *SynxDB Administrator Guide*.
</code></pre>
<p><strong>compresslevel</strong> — For Zstd compression of append-optimized tables, set to an integer value from 1 (fastest compression) to 19 (highest compression ratio). For zlib compression, the valid range is from 1 to 9. If not declared, the default is 1. For <code>RLE_TYPE</code>, the compression level can be an integer value from 1 (fastest compression) to 4 (highest compression ratio).</p>
<p>The <code>compresslevel</code> option is valid only if <code>appendoptimized=TRUE</code>.</p>
<p><strong>fillfactor</strong> — The fillfactor for a table is a percentage between 10 and 100. 100 (complete packing) is the default. When a smaller fillfactor is specified, <code>INSERT</code> operations pack table pages only to the indicated percentage; the remaining space on each page is reserved for updating rows on that page. This gives <code>UPDATE</code> a chance to place the updated copy of a row on the same page as the original, which is more efficient than placing it on a different page. For a table whose entries are never updated, complete packing is the best choice, but in heavily updated tables smaller fillfactors are appropriate. This parameter cannot be set for TOAST tables.</p>
<p>The fillfactor option is valid only for heap tables (<code>appendoptimized=FALSE</code>).</p>
<p><strong>analyze_hll_non_part_table</strong> — Set this storage parameter to <code>true</code> to force collection of HLL statistics even if the table is not part of a partitioned table. This is useful if the table will be exchanged or added to a partitioned table, so that the table does not need to be re-analyzed. The default is <code>false</code>.</p>
<p><strong>oids=FALSE</strong> — This setting is the default, and it ensures that rows do not have object identifiers assigned to them. SynxDB does not support using <code>WITH OIDS</code> or <code>oids=TRUE</code> to assign an OID system column.On large tables, such as those in a typical SynxDB system, using OIDs for table rows can cause wrap-around of the 32-bit OID counter. Once the counter wraps around, OIDs can no longer be assumed to be unique, which not only makes them useless to user applications, but can also cause problems in the SynxDB system catalog tables. In addition, excluding OIDs from a table reduces the space required to store the table on disk by 4 bytes per row, slightly improving performance. You cannot create OIDS on a partitioned or column-oriented table (an error is displayed). This syntax is deprecated and will be removed in a future SynxDB release.</p>
<h3 id="on-commit"><a class="header" href="#on-commit">ON COMMIT</a></h3>
<p>The behavior of temporary tables at the end of a transaction block can be controlled using <code>ON COMMIT</code>. The three options are:</p>
<p><strong>PRESERVE ROWS</strong> - No special action is taken at the ends of transactions for temporary tables. This is the default behavior.</p>
<p><strong>DELETE ROWS</strong> - All rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automatic <code>TRUNCATE</code> is done at each commit.</p>
<p><strong>DROP</strong> - The temporary table will be dropped at the end of the current transaction block.</p>
<h3 id="tablespace-tablespace"><a class="header" href="#tablespace-tablespace">TABLESPACE tablespace</a></h3>
<p>The name of the tablespace in which the new table is to be created. If not specified, the database’s default tablespace is used, or <a href="../config_params/guc-list.html">temp_tablespaces</a> if the table is temporary.</p>
<h3 id="using-index-tablespace-tablespace"><a class="header" href="#using-index-tablespace-tablespace">USING INDEX TABLESPACE tablespace</a></h3>
<p>This clause allows selection of the tablespace in which the index associated with a <code>UNIQUE</code> or <code>PRIMARY KEY</code> constraint will be created. If not specified, the database’s default tablespace is used, or <a href="../config_params/guc-list.html">temp_tablespaces</a> if the table is temporary.</p>
<h3 id="distributed-by-column-opclass----distributed-randomlydistributed-replicated"><a class="header" href="#distributed-by-column-opclass----distributed-randomlydistributed-replicated">DISTRIBUTED BY (column [opclass], [ … ] )<br/>DISTRIBUTED RANDOMLY<br/>DISTRIBUTED REPLICATED</a></h3>
<p>Used to declare the SynxDB distribution policy for the table. <code>DISTRIBUTED BY</code> uses hash distribution with one or more columns declared as the distribution key. For the most even data distribution, the distribution key should be the primary key of the table or a unique column (or set of columns). If that is not possible, then you may choose <code>DISTRIBUTED RANDOMLY</code>, which will send the data round-robin to the segment instances. Additionally, an operator class, <code>opclass</code>, can be specified, to use a non-default hash function.</p>
<p>The SynxDB server configuration parameter <code>gp_create_table_random_default_distribution</code> controls the default table distribution policy if the DISTRIBUTED BY clause is not specified when you create a table. SynxDB follows these rules to create a table if a distribution policy is not specified.</p>
<pre><code>If the value of the parameter is `off` \(the default\), SynxDB chooses the table distribution key based on the command:

-   If a `LIKE` or `INHERITS` clause is specified, then SynxDB copies the distribution key from the source or parent table.
-   If a `PRIMARY KEY` or `UNIQUE` constraints are specified, then SynxDB chooses the largest subset of all the key columns as the distribution key.
-   If neither constraints nor a `LIKE` or `INHERITS` clause is specified, then SynxDB chooses the first suitable column as the distribution key. \(Columns with geometric or user-defined data types are not eligible as SynxDB distribution key columns.\)

If the value of the parameter is set to `on`, SynxDB follows these rules:

-   If PRIMARY KEY or UNIQUE columns are not specified, the distribution of the table is random \(DISTRIBUTED RANDOMLY\). Table distribution is random even if the table creation command contains the LIKE or INHERITS clause.
-   If PRIMARY KEY or UNIQUE columns are specified, a DISTRIBUTED BY clause must also be specified. If a DISTRIBUTED BY clause is not specified as part of the table creation command, the command fails.
</code></pre>
<p>For more information about setting the default table distribution policy, see <a href="../config_params/guc-list.html"><code>gp_create_table_random_default_distribution</code></a>.</p>
<p>The <code>DISTRIBUTED REPLICATED</code> clause replicates the entire table to all SynxDB segment instances. It can be used when it is necessary to run user-defined functions on segments when the functions require access to all rows in the table, or to improve query performance by preventing broadcast motions.</p>
<h3 id="partition-by"><a class="header" href="#partition-by"><a id="part_by"></a>PARTITION BY</a></h3>
<p>Declares one or more columns by which to partition the table.</p>
<p>When creating a partitioned table, SynxDB creates the root partitioned table (the root partition) with the specified table name. SynxDB also creates a hierarchy of tables, child tables, that are the subpartitions based on the partitioning options that you specify. The SynxDB <em>pg_partition</em>* system views contain information about the subpartition tables.</p>
<p>For each partition level (each hierarchy level of tables), a partitioned table can have a maximum of 32,767 partitions.</p>
<blockquote>
<p><strong>Note</strong> SynxDB stores partitioned table data in the leaf child tables, the lowest-level tables in the hierarchy of child tables for use by the partitioned table.</p>
</blockquote>
<h3 id="partition_type"><a class="header" href="#partition_type">partition_type</a></h3>
<p>Declares partition type: <code>LIST</code> (list of values) or <code>RANGE</code> (a numeric or date range).</p>
<h3 id="partition_specification"><a class="header" href="#partition_specification">partition_specification</a></h3>
<p>Declares the individual partitions to create. Each partition can be defined individually or, for range partitions, you can use the <code>EVERY</code> clause (with a <code>START</code> and optional <code>END</code> clause) to define an increment pattern to use to create the individual partitions.</p>
<p><strong><code>DEFAULT PARTITION name</code></strong> — Declares a default partition. When data does not match to an existing partition, it is inserted into the default partition. Partition designs that do not have a default partition will reject incoming rows that do not match to an existing partition.</p>
<p><strong><code>PARTITION name</code></strong> — Declares a name to use for the partition. Partitions are created using the following naming convention: <code>parentname_level\#_prt_givenname</code>.</p>
<p><strong><code>VALUES</code></strong> — For list partitions, defines the value(s) that the partition will contain.</p>
<p><strong><code>START</code></strong> — For range partitions, defines the starting range value for the partition. By default, start values are <code>INCLUSIVE</code>. For example, if you declared a start date of ‘<code>2016-01-01</code>’, then the partition would contain all dates greater than or equal to ‘<code>2016-01-01</code>’. Typically the data type of the <code>START</code> expression is the same type as the partition key column. If that is not the case, then you must explicitly cast to the intended data type.</p>
<p><strong><code>END</code></strong> — For range partitions, defines the ending range value for the partition. By default, end values are <code>EXCLUSIVE</code>. For example, if you declared an end date of ‘<code>2016-02-01</code>’, then the partition would contain all dates less than but not equal to ‘<code>2016-02-01</code>’. Typically the data type of the <code>END</code> expression is the same type as the partition key column. If that is not the case, then you must explicitly cast to the intended data type.</p>
<p><strong><code>EVERY</code></strong> — For range partitions, defines how to increment the values from <code>START</code> to <code>END</code> to create individual partitions. Typically the data type of the <code>EVERY</code> expression is the same type as the partition key column. If that is not the case, then you must explicitly cast to the intended data type.</p>
<p><strong><code>WITH</code></strong>— Sets the table storage options for a partition. For example, you may want older partitions to be append-optimized tables and newer partitions to be regular heap tables.</p>
<p><strong><code>TABLESPACE</code></strong> — The name of the tablespace in which the partition is to be created.</p>
<h3 id="subpartition-by"><a class="header" href="#subpartition-by">SUBPARTITION BY</a></h3>
<p>Declares one or more columns by which to subpartition the first-level partitions of the table. The format of the subpartition specification is similar to that of a partition specification described above.</p>
<h3 id="subpartition-template"><a class="header" href="#subpartition-template">SUBPARTITION TEMPLATE</a></h3>
<p>Instead of declaring each subpartition definition individually for each partition, you can optionally declare a subpartition template to be used to create the subpartitions (lower level child tables). This subpartition specification would then apply to all parent partitions.</p>
<h2 id="notes"><a class="header" href="#notes"><a id="section5"></a>Notes</a></h2>
<ul>
<li>
<p>In SynxDB (a Postgres-based system) the data types <code>VARCHAR</code> or <code>TEXT</code> handle padding added to the textual data (space characters added after the last non-space character) as significant characters; the data type <code>CHAR</code> does not.</p>
<p>In SynxDB, values of type <code>CHAR(n)</code> are padded with trailing spaces to the specified width n. The values are stored and displayed with the spaces. However, the padding spaces are treated as semantically insignificant. When the values are distributed, the trailing spaces are disregarded. The trailing spaces are also treated as semantically insignificant when comparing two values of data type <code>CHAR</code>, and the trailing spaces are removed when converting a character value to one of the other string types.</p>
</li>
<li>
<p>SynxDB does not support using <code>WITH OIDS</code> or <code>oids=TRUE</code> to assign an OID system column.Using OIDs in new applications is not recommended. This syntax is deprecated and will be removed in a future SynxDB release. As an alternative, use a <code>SERIAL</code> or other sequence generator as the table’s primary key. However, if your application does make use of OIDs to identify specific rows of a table, it is recommended to create a unique constraint on the OID column of that table, to ensure that OIDs in the table will indeed uniquely identify rows even after counter wrap-around. Avoid assuming that OIDs are unique across tables; if you need a database-wide unique identifier, use the combination of table OID and row OID for that purpose.</p>
</li>
<li>
<p>SynxDB has some special conditions for primary key and unique constraints with regards to columns that are the <em>distribution key</em> in a SynxDB table. For a unique constraint to be enforced in SynxDB, the table must be hash-distributed (not <code>DISTRIBUTED RANDOMLY</code>), and the constraint columns must be the same as (or a superset of) the table’s distribution key columns.</p>
<p>Replicated tables (<code>DISTRIBUTED REPLICATED</code>) can have both <code>PRIMARY KEY</code> and <code>UNIQUE</code>column constraints.</p>
<p>A primary key constraint is simply a combination of a unique constraint and a not-null constraint.</p>
<p>SynxDB automatically creates a <code>UNIQUE</code> index for each <code>UNIQUE</code> or <code>PRIMARY KEY</code> constraint to enforce uniqueness. Thus, it is not necessary to create an index explicitly for primary key columns. <code>UNIQUE</code> and <code>PRIMARY KEY</code> constraints are not allowed on append-optimized tables because the <code>UNIQUE</code> indexes that are created by the constraints are not allowed on append-optimized tables.</p>
<p>Foreign key constraints are not supported in SynxDB.</p>
<p>For inherited tables, unique constraints, primary key constraints, indexes and table privileges are <em>not</em> inherited in the current implementation.</p>
</li>
<li>
<p>For append-optimized tables, <code>UPDATE</code> and <code>DELETE</code> are not allowed in a repeatable read or serializable transaction and will cause the transaction to end prematurely. <code>DECLARE...FOR UPDATE</code>, and triggers are not supported with append-optimized tables. <code>CLUSTER</code> on append-optimized tables is only supported over B-tree indexes.</p>
</li>
<li>
<p>To insert data into a partitioned table, you specify the root partitioned table, the table created with the <code>CREATE TABLE</code> command. You also can specify a leaf child table of the partitioned table in an <code>INSERT</code> command. An error is returned if the data is not valid for the specified leaf child table. Specifying a child table that is not a leaf child table in the <code>INSERT</code> command is not supported. Execution of other DML commands such as <code>UPDATE</code> and <code>DELETE</code> on any child table of a partitioned table is not supported. These commands must be run on the root partitioned table, the table created with the <code>CREATE TABLE</code> command.</p>
</li>
<li>
<p>The default values for these table storage options can be specified with the server configuration parameter <code>gp_default_storage_option</code>.</p>
<ul>
<li>appendoptimized</li>
<li>blocksize</li>
<li>checksum</li>
<li>compresstype</li>
<li>compresslevel</li>
<li>orientation
The defaults can be set for the system, a database, or a user. For information about setting storage options, see the server configuration parameter <a href="../config_params/guc-list.html">gp_default_storage_options</a>.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Important</strong> The current Postgres Planner allows list partitions with multi-column (composite) partition keys. GPORCA does not support composite keys, so using composite partition keys is not recommended.</p>
</blockquote>
<h2 id="examples"><a class="header" href="#examples"><a id="section6"></a>Examples</a></h2>
<p>Create a table named <code>rank</code> in the schema named <code>baby</code> and distribute the data using the columns <code>rank</code>, <code>gender</code>, and <code>year</code>:</p>
<pre><code>CREATE TABLE baby.rank (id int, rank int, year smallint, 
gender char(1), count int ) DISTRIBUTED BY (rank, gender, 
year);
</code></pre>
<p>Create table films and table distributors (the primary key will be used as the SynxDB distribution key by default):</p>
<pre><code>CREATE TABLE films (
code        char(5) CONSTRAINT firstkey PRIMARY KEY,
title       varchar(40) NOT NULL,
did         integer NOT NULL,
date_prod   date,
kind        varchar(10),
len         interval hour to minute
);

CREATE TABLE distributors (
did    integer PRIMARY KEY DEFAULT nextval('serial'),
name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);
</code></pre>
<p>Create a gzip-compressed, append-optimized table:</p>
<pre><code>CREATE TABLE sales (txn_id int, qty int, date date) 
WITH (appendoptimized=true, compresslevel=5) 
DISTRIBUTED BY (txn_id);
</code></pre>
<p>Create a simple, single level partitioned table:</p>
<pre><code>CREATE TABLE sales (id int, year int, qtr int, c_rank int, code char(1), region text)
DISTRIBUTED BY (id)
PARTITION BY LIST (code)
( PARTITION sales VALUES ('S'),
  PARTITION returns VALUES ('R')
);
</code></pre>
<p>Create a three level partitioned table that defines subpartitions without the <code>SUBPARTITION TEMPLATE</code> clause:</p>
<pre><code>CREATE TABLE sales (id int, year int, qtr int, c_rank int, code char(1), region text)
DISTRIBUTED BY (id)
PARTITION BY LIST (code)
  SUBPARTITION BY RANGE (c_rank)
    SUBPARTITION by LIST (region)

( PARTITION sales VALUES ('S')
   ( SUBPARTITION cr1 START (1) END (2)
      ( SUBPARTITION ca VALUES ('CA') ), 
      SUBPARTITION cr2 START (3) END (4)
        ( SUBPARTITION ca VALUES ('CA') ) ),

 PARTITION returns VALUES ('R')
   ( SUBPARTITION cr1 START (1) END (2)
      ( SUBPARTITION ca VALUES ('CA') ), 
     SUBPARTITION cr2 START (3) END (4)
        ( SUBPARTITION ca VALUES ('CA') ) )
);
</code></pre>
<p>Create the same partitioned table as the previous table using the <code>SUBPARTITION TEMPLATE</code> clause:</p>
<pre><code>CREATE TABLE sales1 (id int, year int, qtr int, c_rank int, code char(1), region text)
DISTRIBUTED BY (id)
PARTITION BY LIST (code)

   SUBPARTITION BY RANGE (c_rank)
     SUBPARTITION TEMPLATE (
     SUBPARTITION cr1 START (1) END (2),
     SUBPARTITION cr2 START (3) END (4) )

     SUBPARTITION BY LIST (region)
       SUBPARTITION TEMPLATE (
       SUBPARTITION ca VALUES ('CA') )

( PARTITION sales VALUES ('S'),
  PARTITION  returns VALUES ('R')
);
</code></pre>
<p>Create a three level partitioned table using subpartition templates and default partitions at each level:</p>
<pre><code>CREATE TABLE sales (id int, year int, qtr int, c_rank int, code char(1), region text)
DISTRIBUTED BY (id)
PARTITION BY RANGE (year)

  SUBPARTITION BY RANGE (qtr)
    SUBPARTITION TEMPLATE (
    START (1) END (5) EVERY (1), 
    DEFAULT SUBPARTITION bad_qtr )

    SUBPARTITION BY LIST (region)
      SUBPARTITION TEMPLATE (
      SUBPARTITION usa VALUES ('usa'),
      SUBPARTITION europe VALUES ('europe'),
      SUBPARTITION asia VALUES ('asia'),
      DEFAULT SUBPARTITION other_regions)

( START (2009) END (2011) EVERY (1),
  DEFAULT PARTITION outlying_years);
</code></pre>
<h2 id="compatibility"><a class="header" href="#compatibility"><a id="section7"></a>Compatibility</a></h2>
<p><code>CREATE TABLE</code> command conforms to the SQL standard, with the following exceptions:</p>
<ul>
<li>
<p><strong>Temporary Tables</strong> — In the SQL standard, temporary tables are defined just once and automatically exist (starting with empty contents) in every session that needs them. SynxDB instead requires each session to issue its own <code>CREATE TEMPORARY TABLE</code> command for each temporary table to be used. This allows different sessions to use the same temporary table name for different purposes, whereas the standard’s approach constrains all instances of a given temporary table name to have the same table structure.</p>
<p>The standard’s distinction between global and local temporary tables is not in SynxDB. SynxDB will accept the <code>GLOBAL</code> and <code>LOCAL</code> keywords in a temporary table declaration, but they have no effect and are deprecated.</p>
<p>If the <code>ON COMMIT</code> clause is omitted, the SQL standard specifies that the default behavior as <code>ON COMMIT DELETE ROWS</code>. However, the default behavior in SynxDB is <code>ON COMMIT PRESERVE ROWS</code>. The <code>ON COMMIT DROP</code> option does not exist in the SQL standard.</p>
</li>
<li>
<p><strong>Column Check Constraints</strong> — The SQL standard says that <code>CHECK</code> column constraints may only refer to the column they apply to; only <code>CHECK</code> table constraints may refer to multiple columns. SynxDB does not enforce this restriction; it treats column and table check constraints alike.</p>
</li>
<li>
<p><strong>NULL Constraint</strong> — The <code>NULL</code> constraint is a SynxDB extension to the SQL standard that is included for compatibility with some other database systems (and for symmetry with the <code>NOT NULL</code> constraint). Since it is the default for any column, its presence is not required.</p>
</li>
<li>
<p><strong>Inheritance</strong> — Multiple inheritance via the <code>INHERITS</code> clause is a SynxDB language extension. SQL:1999 and later define single inheritance using a different syntax and different semantics. SQL:1999-style inheritance is not yet supported by SynxDB.</p>
</li>
<li>
<p><strong>Partitioning</strong> — Table partitioning via the <code>PARTITION BY</code> clause is a SynxDB language extension.</p>
</li>
<li>
<p><strong>Zero-column tables</strong> — SynxDB allows a table of no columns to be created (for example, <code>CREATE TABLE foo();</code>). This is an extension from the SQL standard, which does not allow zero-column tables. Zero-column tables are not in themselves very useful, but disallowing them creates odd special cases for <code>ALTER TABLE DROP COLUMN</code>, so SynxDB decided to ignore this spec restriction.</p>
</li>
<li>
<p><strong>LIKE</strong> — While a <code>LIKE</code> clause exists in the SQL standard, many of the options that SynxDB accepts for it are not in the standard, and some of the standard’s options are not implemented by SynxDB.</p>
</li>
<li>
<p><strong>WITH clause</strong> — The <code>WITH</code> clause is a SynxDB extension; neither storage parameters nor OIDs are in the standard.</p>
</li>
<li>
<p><strong>Tablespaces</strong> — The SynxDB concept of tablespaces is not part of the SQL standard. The clauses <code>TABLESPACE</code> and <code>USING INDEX TABLESPACE</code> are extensions.</p>
</li>
<li>
<p><strong>Data Distribution</strong> — The SynxDB concept of a parallel or distributed database is not part of the SQL standard. The <code>DISTRIBUTED</code> clauses are extensions.</p>
</li>
</ul>
<h2 id="see-also"><a class="header" href="#see-also"><a id="section8"></a>See Also</a></h2>
<p><a href="ALTER_TABLE.html">ALTER TABLE</a>, <a href="DROP_TABLE.html">DROP TABLE</a>, <a href="CREATE_EXTERNAL_TABLE.html">CREATE EXTERNAL TABLE</a>, <a href="CREATE_TABLE_AS.html">CREATE TABLE AS</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../ref_guide/sql_commands/CREATE_SERVER.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../ref_guide/sql_commands/CREATE_TABLE_AS.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../ref_guide/sql_commands/CREATE_SERVER.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../ref_guide/sql_commands/CREATE_TABLE_AS.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
