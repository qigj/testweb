<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CREATE AGGREGATE - SynxDB 2 Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SynxDB 2 Documentation</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                        &nbsp;&nbsp;&nbsp;&nbsp;
                        <a href="https://www.synxdata.com/"><img id="fa fa-print" src="../../SYNX-Text-and-Circular-Logo-142x28-White-text-Black-background.png" alt="Synx Data Labs Logo"/></a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="create-aggregate"><a class="header" href="#create-aggregate">CREATE AGGREGATE</a></h1>
<p>Defines a new aggregate function.</p>
<h2 id="synopsis"><a class="header" href="#synopsis"><a id="section2"></a>Synopsis</a></h2>
<pre><code class="language-{#sql_command_synopsis}">CREATE AGGREGATE &lt;name&gt; ( [ &lt;argmode&gt; ] [ &lt;argname&gt; ] &lt;arg_data_type&gt; [ , ... ] ) (
    SFUNC = &lt;statefunc&gt;,
    STYPE = &lt;state_data_type&gt;
    [ , SSPACE = &lt;state_data_size&gt; ]
    [ , FINALFUNC = &lt;ffunc&gt; ]
    [ , FINALFUNC_EXTRA ]
    [ , COMBINEFUNC = &lt;combinefunc&gt; ]
    [ , SERIALFUNC = &lt;serialfunc&gt; ]
    [ , DESERIALFUNC = &lt;deserialfunc&gt; ]
    [ , INITCOND = &lt;initial_condition&gt; ]
    [ , MSFUNC = &lt;msfunc&gt; ]
    [ , MINVFUNC = &lt;minvfunc&gt; ]
    [ , MSTYPE = &lt;mstate_data_type&gt; ]
    [ , MSSPACE = &lt;mstate_data_size&gt; ]
    [ , MFINALFUNC = &lt;mffunc&gt; ]
    [ , MFINALFUNC_EXTRA ]
    [ , MINITCOND = &lt;minitial_condition&gt; ]
    [ , SORTOP = &lt;sort_operator&gt; ]
  )
  
  CREATE AGGREGATE &lt;name&gt; ( [ [ &lt;argmode&gt; ] [ &lt;argname&gt; ] &lt;arg_data_type&gt; [ , ... ] ]
      ORDER BY [ &lt;argmode&gt; ] [ &lt;argname&gt; ] &lt;arg_data_type&gt; [ , ... ] ) (
    SFUNC = &lt;statefunc&gt;,
    STYPE = &lt;state_data_type&gt;
    [ , SSPACE = &lt;state_data_size&gt; ]
    [ , FINALFUNC = &lt;ffunc&gt; ]
    [ , FINALFUNC_EXTRA ]
    [ , COMBINEFUNC = &lt;combinefunc&gt; ]
    [ , SERIALFUNC = &lt;serialfunc&gt; ]
    [ , DESERIALFUNC = &lt;deserialfunc&gt; ]
    [ , INITCOND = &lt;initial_condition&gt; ]
    [ , HYPOTHETICAL ]
  )
  
  or the old syntax
  
  CREATE AGGREGATE &lt;name&gt; (
    BASETYPE = &lt;base_type&gt;,
    SFUNC = &lt;statefunc&gt;,
    STYPE = &lt;state_data_type&gt;
    [ , SSPACE = &lt;state_data_size&gt; ]
    [ , FINALFUNC = &lt;ffunc&gt; ]
    [ , FINALFUNC_EXTRA ]
    [ , COMBINEFUNC = &lt;combinefunc&gt; ]
    [ , SERIALFUNC = &lt;serialfunc&gt; ]
    [ , DESERIALFUNC = &lt;deserialfunc&gt; ]
    [ , INITCOND = &lt;initial_condition&gt; ]
    [ , MSFUNC = &lt;msfunc&gt; ]
    [ , MINVFUNC = &lt;minvfunc&gt; ]
    [ , MSTYPE = &lt;mstate_data_type&gt; ]
    [ , MSSPACE = &lt;mstate_data_size&gt; ]
    [ , MFINALFUNC = &lt;mffunc&gt; ]
    [ , MFINALFUNC_EXTRA ]
    [ , MINITCOND = &lt;minitial_condition&gt; ]
    [ , SORTOP = &lt;sort_operator&gt; ]
  )
</code></pre>
<h2 id="description"><a class="header" href="#description"><a id="section3"></a>Description</a></h2>
<p><code>CREATE AGGREGATE</code> defines a new aggregate function. Some basic and commonly-used aggregate functions such as <code>count</code>, <code>min</code>, <code>max</code>, <code>sum</code>, <code>avg</code> and so on are already provided in SynxDB. If you define new types or need an aggregate function not already provided, you can use <code>CREATE AGGREGATE</code> to provide the desired features.</p>
<p>If a schema name is given (for example, <code>CREATE AGGREGATE myschema.myagg ...</code>) then the aggregate function is created in the specified schema. Otherwise it is created in the current schema.</p>
<p>An aggregate function is identified by its name and input data types. Two aggregate functions in the same schema can have the same name if they operate on different input types. The name and input data types of an aggregate function must also be distinct from the name and input data types of every ordinary function in the same schema. This behavior is identical to overloading of ordinary function names. See <a href="CREATE_FUNCTION.html">CREATE FUNCTION</a>.</p>
<p>A simple aggregate function is made from one, two, or three ordinary functions (which must be <code>IMMUTABLE</code> functions):</p>
<ul>
<li>a state transition function statefunc</li>
<li>an optional final calculation function ffunc</li>
<li>an optional combine function combinefunc</li>
</ul>
<p>These functions are used as follows:</p>
<pre><code>&lt;statefunc&gt;( internal-state, next-data-values ) ---&gt; next-internal-state
&lt;ffunc&gt;( internal-state ) ---&gt; aggregate-value
&lt;combinefunc&gt;( internal-state, internal-state ) ---&gt; next-internal-state
</code></pre>
<p>SynxDB creates a temporary variable of data type state_data_type to hold the current internal state of the aggregate function. At each input row, the aggregate argument values are calculated and the state transition function is invoked with the current state value and the new argument values to calculate a new internal state value. After all the rows have been processed, the final function is invoked once to calculate the aggregate return value. If there is no final function then the ending state value is returned as-is.</p>
<blockquote>
<p><strong>Note</strong> If you write a user-defined aggregate in C, and you declare the state value (state_data_type) as type <code>internal</code>, there is a risk of an out-of-memory error occurring. If <code>internal</code> state values are not properly managed and a query acquires too much memory for state values, an out-of-memory error could occur. To prevent this, use <code>mpool_alloc(mpool, size)</code> to have SynxDB manage and allocate memory for non-temporary state values, that is, state values that have a lifespan for the entire aggregation. The argument <code>mpool</code> of the <code>mpool_alloc()</code> function is <code>aggstate-&gt;hhashtable-&gt;group_buf</code>. For an example, see the implementation of the numeric data type aggregates in <code>src/backend/utils/adt/numeric.c</code> in the SynxDB open source code.</p>
</blockquote>
<p>You can specify <code>combinefunc</code> as a method for optimizing aggregate execution. By specifying <code>combinefunc</code>, the aggregate can be run in parallel on segments first and then on the master. When a two-level execution is performed, the <code>statefunc</code> is run on the segments to generate partial aggregate results, and <code>combinefunc</code> is run on the master to aggregate the partial results from segments. If single-level aggregation is performed, all the rows are sent to the master and the <code>statefunc</code> is applied to the rows.</p>
<p>Single-level aggregation and two-level aggregation are equivalent execution strategies. Either type of aggregation can be implemented in a query plan. When you implement the functions <code>combinefunc</code> and <code>statefunc</code>, you must ensure that the invocation of the <code>statefunc</code> on the segment instances followed by <code>combinefunc</code> on the master produce the same result as single-level aggregation that sends all the rows to the master and then applies only the <code>statefunc</code> to the rows.</p>
<p>An aggregate function can provide an optional initial condition, an initial value for the internal state value. This is specified and stored in the database as a value of type <code>text</code>, but it must be a valid external representation of a constant of the state value data type. If it is not supplied then the state value starts out <code>NULL</code>.</p>
<p>If <code>statefunc</code> is declared <code>STRICT</code>, then it cannot be called with <code>NULL</code> inputs. With such a transition function, aggregate execution behaves as follows. Rows with any null input values are ignored (the function is not called and the previous state value is retained). If the initial state value is <code>NULL</code>, then at the first row with all non-null input values, the first argument value replaces the state value, and the transition function is invoked at subsequent rows with all non-null input values. This is useful for implementing aggregates like <code>max</code>. Note that this behavior is only available when state_data_type is the same as the first arg_data_type. When these types are different, you must supply a non-null initial condition or use a nonstrict transition function.</p>
<p>If statefunc is not declared <code>STRICT</code>, then it will be called unconditionally at each input row, and must deal with <code>NULL</code> inputs and <code>NULL</code> state values for itself. This allows the aggregate author to have full control over the aggregate’s handling of <code>NULL</code> values.</p>
<p>If the final function (<code>ffunc</code>) is declared <code>STRICT</code>, then it will not be called when the ending state value is <code>NULL</code>; instead a <code>NULL</code> result will be returned automatically. (This is the normal behavior of <code>STRICT</code> functions.) In any case the final function has the option of returning a <code>NULL</code> value. For example, the final function for <code>avg</code> returns <code>NULL</code> when it sees there were zero input rows.</p>
<p>Sometimes it is useful to declare the final function as taking not just the state value, but extra parameters corresponding to the aggregate’s input values. The main reason for doing this is if the final function is polymorphic and the state value’s data type would be inadequate to pin down the result type. These extra parameters are always passed as <code>NULL</code> (and so the final function must not be strict when the <code>FINALFUNC_EXTRA</code> option is used), but nonetheless they are valid parameters. The final function could for example make use of <code>get_fn_expr_argtype</code> to identify the actual argument type in the current call.</p>
<p>An aggregate can optionally support <em>moving-aggregate mode</em>, as described in <a href="https://www.postgresql.org/docs/9.4/xaggr.html#XAGGR-MOVING-AGGREGATES">Moving-Aggregate Mode</a> in the PostgreSQL documentation. This requires specifying the <code>msfunc</code>, <code>minvfunc</code>, and <code>mstype</code> functions, and optionally the <code>mspace</code>, <code>mfinalfunc</code>, <code>mfinalfunc\_extra</code>, and <code>minitcond</code> functions. Except for <code>minvfunc</code>, these functions work like the corresponding simple-aggregate functions without <code>m</code>; they define a separate implementation of the aggregate that includes an inverse transition function.</p>
<p>The syntax with <code>ORDER BY</code> in the parameter list creates a special type of aggregate called an <em>ordered-set aggregate</em>; or if <code>HYPOTHETICAL</code> is specified, then a <em>hypothetical-set aggregate</em> is created. These aggregates operate over groups of sorted values in order-dependent ways, so that specification of an input sort order is an essential part of a call. Also, they can have <em>direct</em> arguments, which are arguments that are evaluated only once per aggregation rather than once per input row. Hypothetical-set aggregates are a subclass of ordered-set aggregates in which some of the direct arguments are required to match, in number and data types, the aggregated argument columns. This allows the values of those direct arguments to be added to the collection of aggregate-input rows as an additional “hypothetical” row.</p>
<p>Single argument aggregate functions, such as <code>min</code> or <code>max</code>, can sometimes be optimized by looking into an index instead of scanning every input row. If this aggregate can be so optimized, indicate it by specifying a <em>sort operator</em>. The basic requirement is that the aggregate must yield the first element in the sort ordering induced by the operator; in other words:</p>
<pre><code>SELECT &lt;agg&gt;(&lt;col&gt;) FROM &lt;tab&gt;; 
</code></pre>
<p>must be equivalent to:</p>
<pre><code>SELECT &lt;col&gt; FROM &lt;tab&gt; ORDER BY &lt;col&gt; USING &lt;sortop&gt; LIMIT 1;
</code></pre>
<p>Further assumptions are that the aggregate function ignores <code>NULL</code> inputs, and that it delivers a <code>NULL</code> result if and only if there were no non-null inputs. Ordinarily, a data type’s <code>&lt;</code> operator is the proper sort operator for <code>MIN</code>, and <code>&gt;</code> is the proper sort operator for <code>MAX</code>. Note that the optimization will never actually take effect unless the specified operator is the “less than” or “greater than” strategy member of a B-tree index operator class.</p>
<p>To be able to create an aggregate function, you must have <code>USAGE</code> privilege on the argument types, the state type(s), and the return type, as well as <code>EXECUTE</code> privilege on the transition and final functions.</p>
<h2 id="parameters"><a class="header" href="#parameters"><a id="section5"></a>Parameters</a></h2>
<h3 id="name"><a class="header" href="#name">name</a></h3>
<p>The name (optionally schema-qualified) of the aggregate function to create.</p>
<h3 id="argmode"><a class="header" href="#argmode">argmode</a></h3>
<p>The mode of an argument: <code>IN</code> or <code>VARIADIC</code>. (Aggregate functions do not support <code>OUT</code> arguments.) If omitted, the default is <code>IN</code>. Only the last argument can be marked <code>VARIADIC</code>.</p>
<h3 id="argname"><a class="header" href="#argname">argname</a></h3>
<p>The name of an argument. This is currently only useful for documentation purposes. If omitted, the argument has no name.</p>
<h3 id="arg_data_type"><a class="header" href="#arg_data_type">arg_data_type</a></h3>
<p>An input data type on which this aggregate function operates. To create a zero-argument aggregate function, write <code>*</code> in place of the list of argument specifications. (An example of such an aggregate is <code>count(*)</code>.)</p>
<h3 id="base_type"><a class="header" href="#base_type">base_type</a></h3>
<p>In the old syntax for <code>CREATE AGGREGATE</code>, the input data type is specified by a <code>basetype</code> parameter rather than being written next to the aggregate name. Note that this syntax allows only one input parameter. To define a zero-argument aggregate function with this syntax, specify the <code>basetype</code> as <code>"ANY"</code> (not <code>*</code>). Ordered-set aggregates cannot be defined with the old syntax.</p>
<h3 id="statefunc"><a class="header" href="#statefunc">statefunc</a></h3>
<p>The name of the state transition function to be called for each input row. For a normal N-argument aggregate function, the state transition function <code>statefunc</code> must take N+1 arguments, the first being of type state_data_type and the rest matching the declared input data types of the aggregate. The function must return a value of type state_data_type. This function takes the current state value and the current input data values, and returns the next state value.</p>
<p>For ordered-set (including hypothetical-set) aggregates, the state transition function statefunc receives only the current state value and the aggregated arguments, not the direct arguments. Otherwise it is the same.</p>
<h3 id="state_data_type"><a class="header" href="#state_data_type">state_data_type</a></h3>
<p>The data type for the aggregate’s state value.</p>
<h3 id="state_data_size"><a class="header" href="#state_data_size">state_data_size</a></h3>
<p>The approximate average size (in bytes) of the aggregate’s state value. If this parameter is omitted or is zero, a default estimate is used based on the state_data_type. The planner uses this value to estimate the memory required for a grouped aggregate query. Large values of this parameter discourage use of hash aggregation.</p>
<h3 id="ffunc"><a class="header" href="#ffunc">ffunc</a></h3>
<p>The name of the final function called to compute the aggregate result after all input rows have been traversed. The function must take a single argument of type state_data_type. The return data type of the aggregate is defined as the return type of this function. If <code>ffunc</code> is not specified, then the ending state value is used as the aggregate result, and the return type is state_data_type.</p>
<p>For ordered-set (including hypothetical-set) aggregates, the final function receives not only the final state value, but also the values of all the direct arguments.</p>
<p>If <code>FINALFUNC_EXTRA</code> is specified, then in addition to the final state value and any direct arguments, the final function receives extra NULL values corresponding to the aggregate’s regular (aggregated) arguments. This is mainly useful to allow correct resolution of the aggregate result type when a polymorphic aggregate is being defined.</p>
<h3 id="combinefunc"><a class="header" href="#combinefunc">combinefunc</a></h3>
<p>The name of a combine function. This is a function of two arguments, both of type state_data_type. It must return a value of state_data_type. A combine function takes two transition state values and returns a new transition state value representing the combined aggregation. In SynxDB, if the result of the aggregate function is computed in a segmented fashion, the combine function is invoked on the individual internal states in order to combine them into an ending internal state.</p>
<p>Note that this function is also called in hash aggregate mode within a segment. Therefore, if you call this aggregate function without a combine function, hash aggregate is never chosen. Since hash aggregate is efficient, consider defining a combine function whenever possible.</p>
<h3 id="serialfunc"><a class="header" href="#serialfunc">serialfunc</a></h3>
<p>An aggregate function whose state_data_type is <code>internal</code> can participate in parallel aggregation only if it has a serialfunc function, which must serialize the aggregate state into a <code>bytea</code> value for transmission to another process. This function must take a single argument of type <code>internal</code> and return type <code>bytea</code>. A corresponding deserialfunc is also required.</p>
<h3 id="deserialfunc"><a class="header" href="#deserialfunc">deserialfunc</a></h3>
<p>Deserialize a previously serialized aggregate state back into state_data_type. This function must take two arguments of types <code>bytea</code> and <code>internal</code>, and produce a result of type <code>internal</code>.</p>
<blockquote>
<p><strong>Note</strong> The second, <code>internal</code> argument is unused, but is required for type safety reasons.</p>
</blockquote>
<h3 id="initial_condition"><a class="header" href="#initial_condition">initial_condition</a></h3>
<p>The initial setting for the state value. This must be a string constant in the form accepted for the data type state_data_type. If not specified, the state value starts out null.</p>
<h3 id="msfunc"><a class="header" href="#msfunc">msfunc</a></h3>
<p>The name of the forward state transition function to be called for each input row in moving-aggregate mode. This is exactly like the regular transition function, except that its first argument and result are of type mstate_data_type, which might be different from state_data_type.</p>
<h3 id="minvfunc"><a class="header" href="#minvfunc">minvfunc</a></h3>
<p>The name of the inverse state transition function to be used in moving-aggregate mode. This function has the same argument and result types as msfunc, but it is used to remove a value from the current aggregate state, rather than add a value to it. The inverse transition function must have the same strictness attribute as the forward state transition function.</p>
<h3 id="mstate_data_type"><a class="header" href="#mstate_data_type">mstate_data_type</a></h3>
<p>The data type for the aggregate’s state value, when using moving-aggregate mode.</p>
<h3 id="mstate_data_size"><a class="header" href="#mstate_data_size">mstate_data_size</a></h3>
<p>The approximate average size (in bytes) of the aggregate’s state value, when using moving-aggregate mode. This works the same as state_data_size.</p>
<h3 id="mffunc"><a class="header" href="#mffunc">mffunc</a></h3>
<p>The name of the final function called to compute the aggregate’s result after all input rows have been traversed, when using moving-aggregate mode. This works the same as ffunc, except that its first argument’s type is mstate_data_type and extra dummy arguments are specified by writing <code>MFINALFUNC_EXTRA</code>. The aggregate result type determined by mffunc or mstate_data_type must match that determined by the aggregate’s regular implementation.</p>
<h3 id="minitial_condition"><a class="header" href="#minitial_condition">minitial_condition</a></h3>
<p>The initial setting for the state value, when using moving-aggregate mode. This works the same as initial_condition.</p>
<h3 id="sort_operator"><a class="header" href="#sort_operator">sort_operator</a></h3>
<p>The associated sort operator for a <code>MIN</code>- or <code>MAX</code>-like aggregate. This is just an operator name (possibly schema-qualified). The operator is assumed to have the same input data types as the aggregate (which must be a single-argument normal aggregate).</p>
<h3 id="hypothetical"><a class="header" href="#hypothetical">HYPOTHETICAL</a></h3>
<p>For ordered-set aggregates only, this flag specifies that the aggregate arguments are to be processed according to the requirements for hypothetical-set aggregates: that is, the last few direct arguments must match the data types of the aggregated (<code>WITHIN GROUP</code>) arguments. The <code>HYPOTHETICAL</code> flag has no effect on run-time behavior, only on parse-time resolution of the data types and collations of the aggregate’s arguments.</p>
<h2 id="notes"><a class="header" href="#notes"><a id="section6"></a>Notes</a></h2>
<p>The ordinary functions used to define a new aggregate function must be defined first. Note that in this release of SynxDB, it is required that the statefunc, ffunc, and combinefunc functions used to create the aggregate are defined as <code>IMMUTABLE</code>.</p>
<p>If the value of the SynxDB server configuration parameter <code>gp_enable_multiphase_agg</code> is <code>off</code>, only single-level aggregation is performed.</p>
<p>Any compiled code (shared library files) for custom functions must be placed in the same location on every host in your SynxDB array (master and all segments). This location must also be in the <code>LD_LIBRARY_PATH</code> so that the server can locate the files.</p>
<p>In previous versions of SynxDB, there was a concept of ordered aggregates. Since version 1, any aggregate can be called as an ordered aggregate, using the syntax:</p>
<pre><code>name ( arg [ , ... ] [ORDER BY sortspec [ , ...]] )
</code></pre>
<p>The <code>ORDERED</code> keyword is accepted for backwards compatibility, but is ignored.</p>
<p>In previous versions of SynxDB, the <code>COMBINEFUNC</code> option was called <code>PREFUNC</code>. It is still accepted for backwards compatibility, as a synonym for <code>COMBINEFUNC</code>.</p>
<h2 id="example"><a class="header" href="#example"><a id="section7"></a>Example</a></h2>
<p>The following simple example creates an aggregate function that computes the sum of two columns.</p>
<p>Before creating the aggregate function, create two functions that are used as the <code>statefunc</code> and <code>combinefunc</code> functions of the aggregate function.</p>
<p>This function is specified as the <code>statefunc</code> function in the aggregate function.</p>
<pre><code>CREATE FUNCTION mysfunc_accum(numeric, numeric, numeric) 
  RETURNS numeric
   AS 'select $1 + $2 + $3'
   LANGUAGE SQL
   IMMUTABLE
   RETURNS NULL ON NULL INPUT;
</code></pre>
<p>This function is specified as the <code>combinefunc</code> function in the aggregate function.</p>
<pre><code>CREATE FUNCTION mycombine_accum(numeric, numeric )
  RETURNS numeric
   AS 'select $1 + $2'
   LANGUAGE SQL
   IMMUTABLE
   RETURNS NULL ON NULL INPUT;
</code></pre>
<p>This <code>CREATE AGGREGATE</code> command creates the aggregate function that adds two columns.</p>
<pre><code>CREATE AGGREGATE agg_prefunc(numeric, numeric) (
   SFUNC = mysfunc_accum,
   STYPE = numeric,
   COMBINEFUNC = mycombine_accum,
   INITCOND = 0 );
</code></pre>
<p>The following commands create a table, adds some rows, and runs the aggregate function.</p>
<pre><code>create table t1 (a int, b int) DISTRIBUTED BY (a);
insert into t1 values
   (10, 1),
   (20, 2),
   (30, 3);
select agg_prefunc(a, b) from t1;
</code></pre>
<p>This <code>EXPLAIN</code> command shows two phase aggregation.</p>
<pre><code>explain select agg_prefunc(a, b) from t1;

QUERY PLAN
-------------------------------------------------------------------------- 
Aggregate (cost=1.10..1.11 rows=1 width=32)  
 -&gt; Gather Motion 2:1 (slice1; segments: 2) (cost=1.04..1.08 rows=1
      width=32)
     -&gt; Aggregate (cost=1.04..1.05 rows=1 width=32)
       -&gt; Seq Scan on t1 (cost=0.00..1.03 rows=2 width=8)
 Optimizer: Pivotal Optimizer (GPORCA)
 (5 rows)
</code></pre>
<h2 id="compatibility"><a class="header" href="#compatibility"><a id="section8"></a>Compatibility</a></h2>
<p><code>CREATE AGGREGATE</code> is a SynxDB language extension. The SQL standard does not provide for user-defined aggregate functions.</p>
<h2 id="see-also"><a class="header" href="#see-also"><a id="section9"></a>See Also</a></h2>
<p><a href="ALTER_AGGREGATE.html">ALTER AGGREGATE</a>, <a href="DROP_AGGREGATE.html">DROP AGGREGATE</a>, <a href="CREATE_FUNCTION.html">CREATE FUNCTION</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../ref_guide/sql_commands/COPY.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../ref_guide/sql_commands/CREATE_CAST.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../ref_guide/sql_commands/COPY.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../ref_guide/sql_commands/CREATE_CAST.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
